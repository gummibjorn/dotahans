/**
 * OpenDota API
 * # Introduction This API provides Dota 2 related data. Please keep request rate to approximately 3/s. 
 *
 * OpenAPI spec version: 17.1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.opendota.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class InlineResponse200 {
    /**
    * match_id
    */
    'matchId': number;
    /**
    * barracks_status_dire
    */
    'barracksStatusDire': number;
    /**
    * barracks_status_radiant
    */
    'barracksStatusRadiant': number;
    /**
    * chat
    */
    'chat': Array<InlineResponse200Chat>;
    /**
    * cluster
    */
    'cluster': number;
    /**
    * cosmetics
    */
    'cosmetics': any;
    /**
    * dire_score
    */
    'direScore': number;
    /**
    * duration
    */
    'duration': number;
    /**
    * engine
    */
    'engine': number;
    /**
    * first_blood_time
    */
    'firstBloodTime': number;
    /**
    * game_mode
    */
    'gameMode': number;
    /**
    * human_players
    */
    'humanPlayers': number;
    /**
    * leagueid
    */
    'leagueid': number;
    /**
    * lobby_type
    */
    'lobbyType': number;
    /**
    * match_seq_num
    */
    'matchSeqNum': number;
    /**
    * negative_votes
    */
    'negativeVotes': number;
    /**
    * objectives
    */
    'objectives': any;
    /**
    * picks_bans
    */
    'picksBans': any;
    /**
    * positive_votes
    */
    'positiveVotes': number;
    /**
    * radiant_gold_adv
    */
    'radiantGoldAdv': any;
    /**
    * radiant_score
    */
    'radiantScore': number;
    /**
    * radiant_win
    */
    'radiantWin': boolean;
    /**
    * radiant_xp_adv
    */
    'radiantXpAdv': any;
    /**
    * start_time
    */
    'startTime': number;
    /**
    * teamfights
    */
    'teamfights': any;
    /**
    * tower_status_dire
    */
    'towerStatusDire': number;
    /**
    * tower_status_radiant
    */
    'towerStatusRadiant': number;
    /**
    * version
    */
    'version': number;
    /**
    * replay_salt
    */
    'replaySalt': number;
    /**
    * series_id
    */
    'seriesId': number;
    /**
    * series_type
    */
    'seriesType': number;
    /**
    * radiant_team
    */
    'radiantTeam': any;
    /**
    * dire_team
    */
    'direTeam': any;
    /**
    * league
    */
    'league': any;
    /**
    * skill
    */
    'skill': number;
    /**
    * players
    */
    'players': Array<InlineResponse200Players>;
    /**
    * patch
    */
    'patch': number;
    /**
    * region
    */
    'region': number;
    /**
    * all_word_counts
    */
    'allWordCounts': any;
    /**
    * my_word_counts
    */
    'myWordCounts': any;
    /**
    * throw
    */
    'throw': number;
    /**
    * loss
    */
    'loss': number;
    /**
    * replay_url
    */
    'replayUrl': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "matchId",
            "baseName": "match_id",
            "type": "number"
        },
        {
            "name": "barracksStatusDire",
            "baseName": "barracks_status_dire",
            "type": "number"
        },
        {
            "name": "barracksStatusRadiant",
            "baseName": "barracks_status_radiant",
            "type": "number"
        },
        {
            "name": "chat",
            "baseName": "chat",
            "type": "Array<InlineResponse200Chat>"
        },
        {
            "name": "cluster",
            "baseName": "cluster",
            "type": "number"
        },
        {
            "name": "cosmetics",
            "baseName": "cosmetics",
            "type": "any"
        },
        {
            "name": "direScore",
            "baseName": "dire_score",
            "type": "number"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "engine",
            "baseName": "engine",
            "type": "number"
        },
        {
            "name": "firstBloodTime",
            "baseName": "first_blood_time",
            "type": "number"
        },
        {
            "name": "gameMode",
            "baseName": "game_mode",
            "type": "number"
        },
        {
            "name": "humanPlayers",
            "baseName": "human_players",
            "type": "number"
        },
        {
            "name": "leagueid",
            "baseName": "leagueid",
            "type": "number"
        },
        {
            "name": "lobbyType",
            "baseName": "lobby_type",
            "type": "number"
        },
        {
            "name": "matchSeqNum",
            "baseName": "match_seq_num",
            "type": "number"
        },
        {
            "name": "negativeVotes",
            "baseName": "negative_votes",
            "type": "number"
        },
        {
            "name": "objectives",
            "baseName": "objectives",
            "type": "any"
        },
        {
            "name": "picksBans",
            "baseName": "picks_bans",
            "type": "any"
        },
        {
            "name": "positiveVotes",
            "baseName": "positive_votes",
            "type": "number"
        },
        {
            "name": "radiantGoldAdv",
            "baseName": "radiant_gold_adv",
            "type": "any"
        },
        {
            "name": "radiantScore",
            "baseName": "radiant_score",
            "type": "number"
        },
        {
            "name": "radiantWin",
            "baseName": "radiant_win",
            "type": "boolean"
        },
        {
            "name": "radiantXpAdv",
            "baseName": "radiant_xp_adv",
            "type": "any"
        },
        {
            "name": "startTime",
            "baseName": "start_time",
            "type": "number"
        },
        {
            "name": "teamfights",
            "baseName": "teamfights",
            "type": "any"
        },
        {
            "name": "towerStatusDire",
            "baseName": "tower_status_dire",
            "type": "number"
        },
        {
            "name": "towerStatusRadiant",
            "baseName": "tower_status_radiant",
            "type": "number"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "replaySalt",
            "baseName": "replay_salt",
            "type": "number"
        },
        {
            "name": "seriesId",
            "baseName": "series_id",
            "type": "number"
        },
        {
            "name": "seriesType",
            "baseName": "series_type",
            "type": "number"
        },
        {
            "name": "radiantTeam",
            "baseName": "radiant_team",
            "type": "any"
        },
        {
            "name": "direTeam",
            "baseName": "dire_team",
            "type": "any"
        },
        {
            "name": "league",
            "baseName": "league",
            "type": "any"
        },
        {
            "name": "skill",
            "baseName": "skill",
            "type": "number"
        },
        {
            "name": "players",
            "baseName": "players",
            "type": "Array<InlineResponse200Players>"
        },
        {
            "name": "patch",
            "baseName": "patch",
            "type": "number"
        },
        {
            "name": "region",
            "baseName": "region",
            "type": "number"
        },
        {
            "name": "allWordCounts",
            "baseName": "all_word_counts",
            "type": "any"
        },
        {
            "name": "myWordCounts",
            "baseName": "my_word_counts",
            "type": "any"
        },
        {
            "name": "throw",
            "baseName": "throw",
            "type": "number"
        },
        {
            "name": "loss",
            "baseName": "loss",
            "type": "number"
        },
        {
            "name": "replayUrl",
            "baseName": "replay_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse200.attributeTypeMap;
    }
}

export class InlineResponse2001 {
    /**
    * tracked_until
    */
    'trackedUntil': string;
    /**
    * solo_competitive_rank
    */
    'soloCompetitiveRank': string;
    /**
    * competitive_rank
    */
    'competitiveRank': string;
    'mmrEstimate': InlineResponse2001MmrEstimate;
    'profile': InlineResponse2001Profile;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "trackedUntil",
            "baseName": "tracked_until",
            "type": "string"
        },
        {
            "name": "soloCompetitiveRank",
            "baseName": "solo_competitive_rank",
            "type": "string"
        },
        {
            "name": "competitiveRank",
            "baseName": "competitive_rank",
            "type": "string"
        },
        {
            "name": "mmrEstimate",
            "baseName": "mmr_estimate",
            "type": "InlineResponse2001MmrEstimate"
        },
        {
            "name": "profile",
            "baseName": "profile",
            "type": "InlineResponse2001Profile"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2001.attributeTypeMap;
    }
}

export class InlineResponse20010 {
    /**
    * obs
    */
    'obs': any;
    /**
    * sen
    */
    'sen': any;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "obs",
            "baseName": "obs",
            "type": "any"
        },
        {
            "name": "sen",
            "baseName": "sen",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20010.attributeTypeMap;
    }
}

export class InlineResponse20011 {
    /**
    * my_word_counts
    */
    'myWordCounts': any;
    /**
    * all_word_counts
    */
    'allWordCounts': any;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "myWordCounts",
            "baseName": "my_word_counts",
            "type": "any"
        },
        {
            "name": "allWordCounts",
            "baseName": "all_word_counts",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20011.attributeTypeMap;
    }
}

export class InlineResponse20012 {
    /**
    * account_id
    */
    'accountId': number;
    /**
    * match_id
    */
    'matchId': number;
    /**
    * solo_competitive_rank
    */
    'soloCompetitiveRank': number;
    /**
    * competitive_rank
    */
    'competitiveRank': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "account_id",
            "type": "number"
        },
        {
            "name": "matchId",
            "baseName": "match_id",
            "type": "number"
        },
        {
            "name": "soloCompetitiveRank",
            "baseName": "solo_competitive_rank",
            "type": "number"
        },
        {
            "name": "competitiveRank",
            "baseName": "competitive_rank",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20012.attributeTypeMap;
    }
}

export class InlineResponse20013 {
    /**
    * account_id
    */
    'accountId': number;
    /**
    * steamid
    */
    'steamid': string;
    /**
    * avatar
    */
    'avatar': string;
    /**
    * avatarmedium
    */
    'avatarmedium': string;
    /**
    * avatarfull
    */
    'avatarfull': string;
    /**
    * profileurl
    */
    'profileurl': string;
    /**
    * personaname
    */
    'personaname': string;
    /**
    * cheese
    */
    'cheese': number;
    /**
    * fh_unavailable
    */
    'fhUnavailable': boolean;
    /**
    * loccountrycode
    */
    'loccountrycode': string;
    /**
    * name
    */
    'name': string;
    /**
    * country_code
    */
    'countryCode': string;
    /**
    * fantasy_role
    */
    'fantasyRole': number;
    /**
    * team_id
    */
    'teamId': number;
    /**
    * team_name
    */
    'teamName': string;
    /**
    * team_tag
    */
    'teamTag': string;
    /**
    * is_locked
    */
    'isLocked': boolean;
    /**
    * is_pro
    */
    'isPro': boolean;
    /**
    * locked_until
    */
    'lockedUntil': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "account_id",
            "type": "number"
        },
        {
            "name": "steamid",
            "baseName": "steamid",
            "type": "string"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "avatarmedium",
            "baseName": "avatarmedium",
            "type": "string"
        },
        {
            "name": "avatarfull",
            "baseName": "avatarfull",
            "type": "string"
        },
        {
            "name": "profileurl",
            "baseName": "profileurl",
            "type": "string"
        },
        {
            "name": "personaname",
            "baseName": "personaname",
            "type": "string"
        },
        {
            "name": "cheese",
            "baseName": "cheese",
            "type": "number"
        },
        {
            "name": "fhUnavailable",
            "baseName": "fh_unavailable",
            "type": "boolean"
        },
        {
            "name": "loccountrycode",
            "baseName": "loccountrycode",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "fantasyRole",
            "baseName": "fantasy_role",
            "type": "number"
        },
        {
            "name": "teamId",
            "baseName": "team_id",
            "type": "number"
        },
        {
            "name": "teamName",
            "baseName": "team_name",
            "type": "string"
        },
        {
            "name": "teamTag",
            "baseName": "team_tag",
            "type": "string"
        },
        {
            "name": "isLocked",
            "baseName": "is_locked",
            "type": "boolean"
        },
        {
            "name": "isPro",
            "baseName": "is_pro",
            "type": "boolean"
        },
        {
            "name": "lockedUntil",
            "baseName": "locked_until",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20013.attributeTypeMap;
    }
}

export class InlineResponse20014 {
    /**
    * match_id
    */
    'matchId': number;
    /**
    * duration
    */
    'duration': number;
    /**
    * start_time
    */
    'startTime': number;
    /**
    * radiant_team_id
    */
    'radiantTeamId': number;
    /**
    * radiant_name
    */
    'radiantName': string;
    /**
    * dire_team_id
    */
    'direTeamId': number;
    /**
    * dire_name
    */
    'direName': string;
    /**
    * leagueid
    */
    'leagueid': number;
    /**
    * league_name
    */
    'leagueName': string;
    /**
    * series_id
    */
    'seriesId': number;
    /**
    * series_type
    */
    'seriesType': number;
    /**
    * radiant_score
    */
    'radiantScore': number;
    /**
    * dire_score
    */
    'direScore': number;
    /**
    * radiant_win
    */
    'radiantWin': boolean;
    /**
    * Whether the team/player/hero was on Radiant
    */
    'radiant': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "matchId",
            "baseName": "match_id",
            "type": "number"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "startTime",
            "baseName": "start_time",
            "type": "number"
        },
        {
            "name": "radiantTeamId",
            "baseName": "radiant_team_id",
            "type": "number"
        },
        {
            "name": "radiantName",
            "baseName": "radiant_name",
            "type": "string"
        },
        {
            "name": "direTeamId",
            "baseName": "dire_team_id",
            "type": "number"
        },
        {
            "name": "direName",
            "baseName": "dire_name",
            "type": "string"
        },
        {
            "name": "leagueid",
            "baseName": "leagueid",
            "type": "number"
        },
        {
            "name": "leagueName",
            "baseName": "league_name",
            "type": "string"
        },
        {
            "name": "seriesId",
            "baseName": "series_id",
            "type": "number"
        },
        {
            "name": "seriesType",
            "baseName": "series_type",
            "type": "number"
        },
        {
            "name": "radiantScore",
            "baseName": "radiant_score",
            "type": "number"
        },
        {
            "name": "direScore",
            "baseName": "dire_score",
            "type": "number"
        },
        {
            "name": "radiantWin",
            "baseName": "radiant_win",
            "type": "boolean"
        },
        {
            "name": "radiant",
            "baseName": "radiant",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20014.attributeTypeMap;
    }
}

export class InlineResponse20015 {
    /**
    * match_id
    */
    'matchId': number;
    /**
    * match_seq_num
    */
    'matchSeqNum': number;
    /**
    * radiant_win
    */
    'radiantWin': boolean;
    /**
    * start_time
    */
    'startTime': number;
    /**
    * duration
    */
    'duration': number;
    /**
    * avg_mmr
    */
    'avgMmr': number;
    /**
    * num_mmr
    */
    'numMmr': number;
    /**
    * radiant_team
    */
    'radiantTeam': string;
    /**
    * dire_team
    */
    'direTeam': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "matchId",
            "baseName": "match_id",
            "type": "number"
        },
        {
            "name": "matchSeqNum",
            "baseName": "match_seq_num",
            "type": "number"
        },
        {
            "name": "radiantWin",
            "baseName": "radiant_win",
            "type": "boolean"
        },
        {
            "name": "startTime",
            "baseName": "start_time",
            "type": "number"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "avgMmr",
            "baseName": "avg_mmr",
            "type": "number"
        },
        {
            "name": "numMmr",
            "baseName": "num_mmr",
            "type": "number"
        },
        {
            "name": "radiantTeam",
            "baseName": "radiant_team",
            "type": "string"
        },
        {
            "name": "direTeam",
            "baseName": "dire_team",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20015.attributeTypeMap;
    }
}

export class InlineResponse20016 {
    /**
    * banner
    */
    'banner': any;
    'cheese': InlineResponse20016Cheese;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "banner",
            "baseName": "banner",
            "type": "any"
        },
        {
            "name": "cheese",
            "baseName": "cheese",
            "type": "InlineResponse20016Cheese"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20016.attributeTypeMap;
    }
}

/**
* cheese
*/
export class InlineResponse20016Cheese {
    /**
    * cheese
    */
    'cheese': string;
    /**
    * goal
    */
    'goal': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cheese",
            "baseName": "cheese",
            "type": "string"
        },
        {
            "name": "goal",
            "baseName": "goal",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20016Cheese.attributeTypeMap;
    }
}

export class InlineResponse20017 {
    'mmr': InlineResponse20017Mmr;
    'countryMmr': InlineResponse20017CountryMmr;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mmr",
            "baseName": "mmr",
            "type": "InlineResponse20017Mmr"
        },
        {
            "name": "countryMmr",
            "baseName": "country_mmr",
            "type": "InlineResponse20017CountryMmr"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20017.attributeTypeMap;
    }
}

/**
* country_mmr
*/
export class InlineResponse20017CountryMmr {
    /**
    * command
    */
    'commmand': string;
    /**
    * rowCount
    */
    'rowCount': number;
    /**
    * rows
    */
    'rows': Array<InlineResponse20017CountryMmrRows>;
    /**
    * fields
    */
    'fields': Array<InlineResponse20017CountryMmrFields>;
    /**
    * rowAsArray
    */
    'rowAsArray': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commmand",
            "baseName": "commmand",
            "type": "string"
        },
        {
            "name": "rowCount",
            "baseName": "rowCount",
            "type": "number"
        },
        {
            "name": "rows",
            "baseName": "rows",
            "type": "Array<InlineResponse20017CountryMmrRows>"
        },
        {
            "name": "fields",
            "baseName": "fields",
            "type": "Array<InlineResponse20017CountryMmrFields>"
        },
        {
            "name": "rowAsArray",
            "baseName": "rowAsArray",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20017CountryMmr.attributeTypeMap;
    }
}

export class InlineResponse20017CountryMmrFields {
    /**
    * name
    */
    'name': string;
    /**
    * tableID
    */
    'tableID': number;
    /**
    * columnID
    */
    'columnID': number;
    /**
    * dataTypeID
    */
    'dataTypeID': number;
    /**
    * dataTypeSize
    */
    'dataTypeSize': number;
    /**
    * dataTypeModifier
    */
    'dataTypeModifier': number;
    /**
    * format
    */
    'format': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "tableID",
            "baseName": "tableID",
            "type": "number"
        },
        {
            "name": "columnID",
            "baseName": "columnID",
            "type": "number"
        },
        {
            "name": "dataTypeID",
            "baseName": "dataTypeID",
            "type": "number"
        },
        {
            "name": "dataTypeSize",
            "baseName": "dataTypeSize",
            "type": "number"
        },
        {
            "name": "dataTypeModifier",
            "baseName": "dataTypeModifier",
            "type": "number"
        },
        {
            "name": "format",
            "baseName": "format",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20017CountryMmrFields.attributeTypeMap;
    }
}

export class InlineResponse20017CountryMmrRows {
    /**
    * loccountrycode
    */
    'loccountrycode': string;
    /**
    * count
    */
    'count': number;
    /**
    * avg
    */
    'avg': string;
    /**
    * common
    */
    'common': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "loccountrycode",
            "baseName": "loccountrycode",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "avg",
            "baseName": "avg",
            "type": "string"
        },
        {
            "name": "common",
            "baseName": "common",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20017CountryMmrRows.attributeTypeMap;
    }
}

/**
* mmr
*/
export class InlineResponse20017Mmr {
    /**
    * command
    */
    'commmand': string;
    /**
    * rowCount
    */
    'rowCount': number;
    /**
    * rows
    */
    'rows': Array<InlineResponse20017MmrRows>;
    /**
    * fields
    */
    'fields': Array<InlineResponse20017MmrFields>;
    /**
    * rowAsArray
    */
    'rowAsArray': boolean;
    'sum': InlineResponse20017MmrSum;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commmand",
            "baseName": "commmand",
            "type": "string"
        },
        {
            "name": "rowCount",
            "baseName": "rowCount",
            "type": "number"
        },
        {
            "name": "rows",
            "baseName": "rows",
            "type": "Array<InlineResponse20017MmrRows>"
        },
        {
            "name": "fields",
            "baseName": "fields",
            "type": "Array<InlineResponse20017MmrFields>"
        },
        {
            "name": "rowAsArray",
            "baseName": "rowAsArray",
            "type": "boolean"
        },
        {
            "name": "sum",
            "baseName": "sum",
            "type": "InlineResponse20017MmrSum"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20017Mmr.attributeTypeMap;
    }
}

export class InlineResponse20017MmrFields {
    /**
    * name
    */
    'name': string;
    /**
    * tableID
    */
    'tableID': number;
    /**
    * columnID
    */
    'columnID': number;
    /**
    * dataTypeID
    */
    'dataTypeID': number;
    /**
    * dataTypeSize
    */
    'dataTypeSize': number;
    /**
    * dataTypeModifier
    */
    'dataTypeModifier': string;
    /**
    * format
    */
    'format': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "tableID",
            "baseName": "tableID",
            "type": "number"
        },
        {
            "name": "columnID",
            "baseName": "columnID",
            "type": "number"
        },
        {
            "name": "dataTypeID",
            "baseName": "dataTypeID",
            "type": "number"
        },
        {
            "name": "dataTypeSize",
            "baseName": "dataTypeSize",
            "type": "number"
        },
        {
            "name": "dataTypeModifier",
            "baseName": "dataTypeModifier",
            "type": "string"
        },
        {
            "name": "format",
            "baseName": "format",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20017MmrFields.attributeTypeMap;
    }
}

export class InlineResponse20017MmrRows {
    /**
    * bin
    */
    'bin': number;
    /**
    * bin_name
    */
    'binName': number;
    /**
    * count
    */
    'count': number;
    /**
    * cumulative_sum
    */
    'cumulativeSum': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bin",
            "baseName": "bin",
            "type": "number"
        },
        {
            "name": "binName",
            "baseName": "bin_name",
            "type": "number"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "cumulativeSum",
            "baseName": "cumulative_sum",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20017MmrRows.attributeTypeMap;
    }
}

/**
* sum
*/
export class InlineResponse20017MmrSum {
    /**
    * count
    */
    'count': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20017MmrSum.attributeTypeMap;
    }
}

export class InlineResponse20018 {
    /**
    * account_id
    */
    'accountId': number;
    /**
    * avatarfull
    */
    'avatarfull': string;
    /**
    * personaname
    */
    'personaname': string;
    /**
    * similarity
    */
    'similarity': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "account_id",
            "type": "number"
        },
        {
            "name": "avatarfull",
            "baseName": "avatarfull",
            "type": "string"
        },
        {
            "name": "personaname",
            "baseName": "personaname",
            "type": "string"
        },
        {
            "name": "similarity",
            "baseName": "similarity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20018.attributeTypeMap;
    }
}

export class InlineResponse20019 {
    /**
    * hero_id
    */
    'heroId': number;
    'rankings': InlineResponse20019Rankings;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "heroId",
            "baseName": "hero_id",
            "type": "number"
        },
        {
            "name": "rankings",
            "baseName": "rankings",
            "type": "InlineResponse20019Rankings"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20019.attributeTypeMap;
    }
}

/**
* rankings
*/
export class InlineResponse20019Rankings {
    /**
    * account_id
    */
    'accountId': number;
    /**
    * score
    */
    'score': string;
    /**
    * steamid
    */
    'steamid': string;
    /**
    * avatar
    */
    'avatar': string;
    /**
    * avatarmedium
    */
    'avatarmedium': string;
    /**
    * avatarfull
    */
    'avatarfull': string;
    /**
    * profileurl
    */
    'profileurl': string;
    /**
    * personaname
    */
    'personaname': string;
    /**
    * cheese
    */
    'cheese': number;
    /**
    * fh_unavailable
    */
    'fhUnavailable': boolean;
    /**
    * loccountrycode
    */
    'loccountrycode': string;
    /**
    * solo_competitive_rank
    */
    'soloCompetitiveRank': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "account_id",
            "type": "number"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "string"
        },
        {
            "name": "steamid",
            "baseName": "steamid",
            "type": "string"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "avatarmedium",
            "baseName": "avatarmedium",
            "type": "string"
        },
        {
            "name": "avatarfull",
            "baseName": "avatarfull",
            "type": "string"
        },
        {
            "name": "profileurl",
            "baseName": "profileurl",
            "type": "string"
        },
        {
            "name": "personaname",
            "baseName": "personaname",
            "type": "string"
        },
        {
            "name": "cheese",
            "baseName": "cheese",
            "type": "number"
        },
        {
            "name": "fhUnavailable",
            "baseName": "fh_unavailable",
            "type": "boolean"
        },
        {
            "name": "loccountrycode",
            "baseName": "loccountrycode",
            "type": "string"
        },
        {
            "name": "soloCompetitiveRank",
            "baseName": "solo_competitive_rank",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20019Rankings.attributeTypeMap;
    }
}

/**
* mmr_estimate
*/
export class InlineResponse2001MmrEstimate {
    /**
    * estimate
    */
    'estimate': number;
    /**
    * stdDev
    */
    'stdDev': number;
    /**
    * n
    */
    'n': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "estimate",
            "baseName": "estimate",
            "type": "number"
        },
        {
            "name": "stdDev",
            "baseName": "stdDev",
            "type": "number"
        },
        {
            "name": "n",
            "baseName": "n",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2001MmrEstimate.attributeTypeMap;
    }
}

/**
* profile
*/
export class InlineResponse2001Profile {
    /**
    * account_id
    */
    'accountId': number;
    /**
    * personaname
    */
    'personaname': string;
    /**
    * name
    */
    'name': string;
    /**
    * cheese
    */
    'cheese': number;
    /**
    * steamid
    */
    'steamid': string;
    /**
    * avatar
    */
    'avatar': string;
    /**
    * avatarmedium
    */
    'avatarmedium': string;
    /**
    * avatarfull
    */
    'avatarfull': string;
    /**
    * profileurl
    */
    'profileurl': string;
    /**
    * last_login
    */
    'lastLogin': string;
    /**
    * loccountrycode
    */
    'loccountrycode': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "account_id",
            "type": "number"
        },
        {
            "name": "personaname",
            "baseName": "personaname",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "cheese",
            "baseName": "cheese",
            "type": "number"
        },
        {
            "name": "steamid",
            "baseName": "steamid",
            "type": "string"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "avatarmedium",
            "baseName": "avatarmedium",
            "type": "string"
        },
        {
            "name": "avatarfull",
            "baseName": "avatarfull",
            "type": "string"
        },
        {
            "name": "profileurl",
            "baseName": "profileurl",
            "type": "string"
        },
        {
            "name": "lastLogin",
            "baseName": "last_login",
            "type": "string"
        },
        {
            "name": "loccountrycode",
            "baseName": "loccountrycode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2001Profile.attributeTypeMap;
    }
}

export class InlineResponse2002 {
    /**
    * win
    */
    'win': number;
    /**
    * lose
    */
    'lose': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "win",
            "baseName": "win",
            "type": "number"
        },
        {
            "name": "lose",
            "baseName": "lose",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2002.attributeTypeMap;
    }
}

export class InlineResponse20020 {
    /**
    * hero_id
    */
    'heroId': number;
    'result': InlineResponse20020Result;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "heroId",
            "baseName": "hero_id",
            "type": "number"
        },
        {
            "name": "result",
            "baseName": "result",
            "type": "InlineResponse20020Result"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20020.attributeTypeMap;
    }
}

/**
* result
*/
export class InlineResponse20020Result {
    'goldPerMin': Array<InlineResponse20020ResultGoldPerMin>;
    'xpPerMin': Array<InlineResponse20020ResultGoldPerMin>;
    'killsPerMin': Array<InlineResponse20020ResultGoldPerMin>;
    'lastHitsPerMin': Array<InlineResponse20020ResultGoldPerMin>;
    'heroDamagePerMin': Array<InlineResponse20020ResultGoldPerMin>;
    'heroHealingPerMin': Array<InlineResponse20020ResultGoldPerMin>;
    'towerDamage': Array<InlineResponse20020ResultGoldPerMin>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "goldPerMin",
            "baseName": "gold_per_min",
            "type": "Array<InlineResponse20020ResultGoldPerMin>"
        },
        {
            "name": "xpPerMin",
            "baseName": "xp_per_min",
            "type": "Array<InlineResponse20020ResultGoldPerMin>"
        },
        {
            "name": "killsPerMin",
            "baseName": "kills_per_min",
            "type": "Array<InlineResponse20020ResultGoldPerMin>"
        },
        {
            "name": "lastHitsPerMin",
            "baseName": "last_hits_per_min",
            "type": "Array<InlineResponse20020ResultGoldPerMin>"
        },
        {
            "name": "heroDamagePerMin",
            "baseName": "hero_damage_per_min",
            "type": "Array<InlineResponse20020ResultGoldPerMin>"
        },
        {
            "name": "heroHealingPerMin",
            "baseName": "hero_healing_per_min",
            "type": "Array<InlineResponse20020ResultGoldPerMin>"
        },
        {
            "name": "towerDamage",
            "baseName": "tower_damage",
            "type": "Array<InlineResponse20020ResultGoldPerMin>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20020Result.attributeTypeMap;
    }
}

export class InlineResponse20020ResultGoldPerMin {
    /**
    * percentile
    */
    'percentile': number;
    /**
    * value
    */
    'value': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "percentile",
            "baseName": "percentile",
            "type": "number"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20020ResultGoldPerMin.attributeTypeMap;
    }
}

export class InlineResponse20021 {
    /**
    * id
    */
    'id': number;
    /**
    * name
    */
    'name': string;
    /**
    * localized_name
    */
    'localizedName': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "localizedName",
            "baseName": "localized_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20021.attributeTypeMap;
    }
}

export class InlineResponse20022 {
    /**
    * id
    */
    'id': number;
    /**
    * name
    */
    'name': string;
    /**
    * localized_name
    */
    'localizedName': string;
    /**
    * img
    */
    'img': string;
    /**
    * icon
    */
    'icon': string;
    /**
    * pro_win
    */
    'proWin': number;
    /**
    * pro_pick
    */
    'proPick': number;
    /**
    * hero_id
    */
    'heroId': number;
    /**
    * pro_ban
    */
    'proBan': number;
    /**
    * 1000_pick
    */
    '1000Pick': number;
    /**
    * 1000_win
    */
    '1000Win': number;
    /**
    * 2000_pick
    */
    '2000Pick': number;
    /**
    * 2000_win
    */
    '2000Win': number;
    /**
    * 3000_pick
    */
    '3000Pick': number;
    /**
    * 3000_win
    */
    '3000Win': number;
    /**
    * 4000_pick
    */
    '4000Pick': number;
    /**
    * 4000_win
    */
    '4000Win': number;
    /**
    * 5000_pick
    */
    '5000Pick': number;
    /**
    * 5000_win
    */
    '5000Win': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "localizedName",
            "baseName": "localized_name",
            "type": "string"
        },
        {
            "name": "img",
            "baseName": "img",
            "type": "string"
        },
        {
            "name": "icon",
            "baseName": "icon",
            "type": "string"
        },
        {
            "name": "proWin",
            "baseName": "pro_win",
            "type": "number"
        },
        {
            "name": "proPick",
            "baseName": "pro_pick",
            "type": "number"
        },
        {
            "name": "heroId",
            "baseName": "hero_id",
            "type": "number"
        },
        {
            "name": "proBan",
            "baseName": "pro_ban",
            "type": "number"
        },
        {
            "name": "1000Pick",
            "baseName": "1000_pick",
            "type": "number"
        },
        {
            "name": "1000Win",
            "baseName": "1000_win",
            "type": "number"
        },
        {
            "name": "2000Pick",
            "baseName": "2000_pick",
            "type": "number"
        },
        {
            "name": "2000Win",
            "baseName": "2000_win",
            "type": "number"
        },
        {
            "name": "3000Pick",
            "baseName": "3000_pick",
            "type": "number"
        },
        {
            "name": "3000Win",
            "baseName": "3000_win",
            "type": "number"
        },
        {
            "name": "4000Pick",
            "baseName": "4000_pick",
            "type": "number"
        },
        {
            "name": "4000Win",
            "baseName": "4000_win",
            "type": "number"
        },
        {
            "name": "5000Pick",
            "baseName": "5000_pick",
            "type": "number"
        },
        {
            "name": "5000Win",
            "baseName": "5000_win",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20022.attributeTypeMap;
    }
}

export class InlineResponse20023 {
    /**
    * Lower bound of number of seconds the match lasted
    */
    'durationBin': string;
    /**
    * Number of games played
    */
    'gamesPlayed': number;
    /**
    * Number of wins
    */
    'wins': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "durationBin",
            "baseName": "duration_bin",
            "type": "string"
        },
        {
            "name": "gamesPlayed",
            "baseName": "games_played",
            "type": "number"
        },
        {
            "name": "wins",
            "baseName": "wins",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20023.attributeTypeMap;
    }
}

export class InlineResponse20024 {
    /**
    * leagueid
    */
    'leagueid': number;
    /**
    * ticket
    */
    'ticket': string;
    /**
    * banner
    */
    'banner': string;
    /**
    * tier
    */
    'tier': string;
    /**
    * name
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "leagueid",
            "baseName": "leagueid",
            "type": "number"
        },
        {
            "name": "ticket",
            "baseName": "ticket",
            "type": "string"
        },
        {
            "name": "banner",
            "baseName": "banner",
            "type": "string"
        },
        {
            "name": "tier",
            "baseName": "tier",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20024.attributeTypeMap;
    }
}

export class InlineResponse20025 {
    /**
    * team_id
    */
    'teamId': number;
    /**
    * The Elo rating of the team
    */
    'rating': number;
    /**
    * The number of games won by this team
    */
    'wins': number;
    /**
    * The number of losses by this team
    */
    'losses': number;
    /**
    * The Unix timestamp of the last match played by this team
    */
    'lastMatchTime': number;
    /**
    * name
    */
    'name': string;
    /**
    * The team tag
    */
    'tag': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamId",
            "baseName": "team_id",
            "type": "number"
        },
        {
            "name": "rating",
            "baseName": "rating",
            "type": "number"
        },
        {
            "name": "wins",
            "baseName": "wins",
            "type": "number"
        },
        {
            "name": "losses",
            "baseName": "losses",
            "type": "number"
        },
        {
            "name": "lastMatchTime",
            "baseName": "last_match_time",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20025.attributeTypeMap;
    }
}

export class InlineResponse20026 {
    /**
    * The player account ID
    */
    'accountId': string;
    /**
    * The player name
    */
    'name': string;
    /**
    * Number of games played
    */
    'gamesPlayed': number;
    /**
    * Number of wins
    */
    'wins': number;
    /**
    * If this player is on the current roster
    */
    'isCurrentTeamMember': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "account_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "gamesPlayed",
            "baseName": "games_played",
            "type": "number"
        },
        {
            "name": "wins",
            "baseName": "wins",
            "type": "number"
        },
        {
            "name": "isCurrentTeamMember",
            "baseName": "is_current_team_member",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20026.attributeTypeMap;
    }
}

export class InlineResponse20027 {
    /**
    * The hero ID
    */
    'heroId': number;
    /**
    * The hero name
    */
    'name': string;
    /**
    * Number of games played
    */
    'gamesPlayed': number;
    /**
    * Number of wins
    */
    'wins': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "heroId",
            "baseName": "hero_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "gamesPlayed",
            "baseName": "games_played",
            "type": "number"
        },
        {
            "name": "wins",
            "baseName": "wins",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20027.attributeTypeMap;
    }
}

export class InlineResponse20028 {
    /**
    * match_id
    */
    'matchId': number;
    /**
    * cluster
    */
    'cluster': number;
    /**
    * replay_salt
    */
    'replaySalt': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "matchId",
            "baseName": "match_id",
            "type": "number"
        },
        {
            "name": "cluster",
            "baseName": "cluster",
            "type": "number"
        },
        {
            "name": "replaySalt",
            "baseName": "replay_salt",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20028.attributeTypeMap;
    }
}

export class InlineResponse20029 {
    /**
    * match_id
    */
    'matchId': number;
    /**
    * start_time
    */
    'startTime': number;
    /**
    * hero_id
    */
    'heroId': number;
    /**
    * score
    */
    'score': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "matchId",
            "baseName": "match_id",
            "type": "number"
        },
        {
            "name": "startTime",
            "baseName": "start_time",
            "type": "number"
        },
        {
            "name": "heroId",
            "baseName": "hero_id",
            "type": "number"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20029.attributeTypeMap;
    }
}

/**
* match
*/
export class InlineResponse2003 {
    /**
    * match_id
    */
    'matchId': number;
    /**
    * player_slot
    */
    'playerSlot': number;
    /**
    * radiant_win
    */
    'radiantWin': boolean;
    /**
    * duration
    */
    'duration': number;
    /**
    * game_mode
    */
    'gameMode': number;
    /**
    * lobby_type
    */
    'lobbyType': number;
    /**
    * hero_id
    */
    'heroId': number;
    /**
    * start_time
    */
    'startTime': number;
    /**
    * version
    */
    'version': number;
    /**
    * kills
    */
    'kills': number;
    /**
    * deaths
    */
    'deaths': number;
    /**
    * assists
    */
    'assists': number;
    /**
    * skill
    */
    'skill': number;
    /**
    * lane
    */
    'lane': number;
    /**
    * lane_role
    */
    'laneRole': number;
    /**
    * is_roaming
    */
    'isRoaming': boolean;
    /**
    * cluster
    */
    'cluster': number;
    /**
    * leaver_status
    */
    'leaverStatus': number;
    /**
    * party_size
    */
    'partySize': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "matchId",
            "baseName": "match_id",
            "type": "number"
        },
        {
            "name": "playerSlot",
            "baseName": "player_slot",
            "type": "number"
        },
        {
            "name": "radiantWin",
            "baseName": "radiant_win",
            "type": "boolean"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "gameMode",
            "baseName": "game_mode",
            "type": "number"
        },
        {
            "name": "lobbyType",
            "baseName": "lobby_type",
            "type": "number"
        },
        {
            "name": "heroId",
            "baseName": "hero_id",
            "type": "number"
        },
        {
            "name": "startTime",
            "baseName": "start_time",
            "type": "number"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "kills",
            "baseName": "kills",
            "type": "number"
        },
        {
            "name": "deaths",
            "baseName": "deaths",
            "type": "number"
        },
        {
            "name": "assists",
            "baseName": "assists",
            "type": "number"
        },
        {
            "name": "skill",
            "baseName": "skill",
            "type": "number"
        },
        {
            "name": "lane",
            "baseName": "lane",
            "type": "number"
        },
        {
            "name": "laneRole",
            "baseName": "lane_role",
            "type": "number"
        },
        {
            "name": "isRoaming",
            "baseName": "is_roaming",
            "type": "boolean"
        },
        {
            "name": "cluster",
            "baseName": "cluster",
            "type": "number"
        },
        {
            "name": "leaverStatus",
            "baseName": "leaver_status",
            "type": "number"
        },
        {
            "name": "partySize",
            "baseName": "party_size",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2003.attributeTypeMap;
    }
}

export class InlineResponse20030 {
    /**
    * table_name
    */
    'tableName': string;
    /**
    * column_name
    */
    'columnName': string;
    /**
    * data_type
    */
    'dataType': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tableName",
            "baseName": "table_name",
            "type": "string"
        },
        {
            "name": "columnName",
            "baseName": "column_name",
            "type": "string"
        },
        {
            "name": "dataType",
            "baseName": "data_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20030.attributeTypeMap;
    }
}

/**
* match
*/
export class InlineResponse2004 {
    /**
    * match_id
    */
    'matchId': number;
    /**
    * player_slot
    */
    'playerSlot': number;
    /**
    * radiant_win
    */
    'radiantWin': boolean;
    /**
    * duration
    */
    'duration': number;
    /**
    * game_mode
    */
    'gameMode': number;
    /**
    * lobby_type
    */
    'lobbyType': number;
    /**
    * hero_id
    */
    'heroId': number;
    /**
    * start_time
    */
    'startTime': number;
    /**
    * version
    */
    'version': number;
    /**
    * kills
    */
    'kills': number;
    /**
    * deaths
    */
    'deaths': number;
    /**
    * assists
    */
    'assists': number;
    /**
    * skill
    */
    'skill': number;
    'heroes': PlayersaccountIdmatchesHeroes;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "matchId",
            "baseName": "match_id",
            "type": "number"
        },
        {
            "name": "playerSlot",
            "baseName": "player_slot",
            "type": "number"
        },
        {
            "name": "radiantWin",
            "baseName": "radiant_win",
            "type": "boolean"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "gameMode",
            "baseName": "game_mode",
            "type": "number"
        },
        {
            "name": "lobbyType",
            "baseName": "lobby_type",
            "type": "number"
        },
        {
            "name": "heroId",
            "baseName": "hero_id",
            "type": "number"
        },
        {
            "name": "startTime",
            "baseName": "start_time",
            "type": "number"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "kills",
            "baseName": "kills",
            "type": "number"
        },
        {
            "name": "deaths",
            "baseName": "deaths",
            "type": "number"
        },
        {
            "name": "assists",
            "baseName": "assists",
            "type": "number"
        },
        {
            "name": "skill",
            "baseName": "skill",
            "type": "number"
        },
        {
            "name": "heroes",
            "baseName": "heroes",
            "type": "PlayersaccountIdmatchesHeroes"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2004.attributeTypeMap;
    }
}

/**
* hero
*/
export class InlineResponse2005 {
    /**
    * hero_id
    */
    'heroId': number;
    /**
    * last_played
    */
    'lastPlayed': number;
    /**
    * games
    */
    'games': number;
    /**
    * win
    */
    'win': number;
    /**
    * with_games
    */
    'withGames': number;
    /**
    * with_win
    */
    'withWin': number;
    /**
    * against_games
    */
    'againstGames': number;
    /**
    * against_win
    */
    'againstWin': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "heroId",
            "baseName": "hero_id",
            "type": "number"
        },
        {
            "name": "lastPlayed",
            "baseName": "last_played",
            "type": "number"
        },
        {
            "name": "games",
            "baseName": "games",
            "type": "number"
        },
        {
            "name": "win",
            "baseName": "win",
            "type": "number"
        },
        {
            "name": "withGames",
            "baseName": "with_games",
            "type": "number"
        },
        {
            "name": "withWin",
            "baseName": "with_win",
            "type": "number"
        },
        {
            "name": "againstGames",
            "baseName": "against_games",
            "type": "number"
        },
        {
            "name": "againstWin",
            "baseName": "against_win",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2005.attributeTypeMap;
    }
}

export class InlineResponse2006 {
    /**
    * account_id
    */
    'accountId': number;
    /**
    * last_played
    */
    'lastPlayed': number;
    /**
    * win
    */
    'win': number;
    /**
    * games
    */
    'games': number;
    /**
    * with_win
    */
    'withWin': number;
    /**
    * with_games
    */
    'withGames': number;
    /**
    * against_win
    */
    'againstWin': number;
    /**
    * against_games
    */
    'againstGames': number;
    /**
    * with_gpm_sum
    */
    'withGpmSum': number;
    /**
    * with_xpm_sum
    */
    'withXpmSum': number;
    /**
    * personaname
    */
    'personaname': string;
    /**
    * last_login
    */
    'lastLogin': string;
    /**
    * avatar
    */
    'avatar': string;
    /**
    * avatarfull
    */
    'avatarfull': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "account_id",
            "type": "number"
        },
        {
            "name": "lastPlayed",
            "baseName": "last_played",
            "type": "number"
        },
        {
            "name": "win",
            "baseName": "win",
            "type": "number"
        },
        {
            "name": "games",
            "baseName": "games",
            "type": "number"
        },
        {
            "name": "withWin",
            "baseName": "with_win",
            "type": "number"
        },
        {
            "name": "withGames",
            "baseName": "with_games",
            "type": "number"
        },
        {
            "name": "againstWin",
            "baseName": "against_win",
            "type": "number"
        },
        {
            "name": "againstGames",
            "baseName": "against_games",
            "type": "number"
        },
        {
            "name": "withGpmSum",
            "baseName": "with_gpm_sum",
            "type": "number"
        },
        {
            "name": "withXpmSum",
            "baseName": "with_xpm_sum",
            "type": "number"
        },
        {
            "name": "personaname",
            "baseName": "personaname",
            "type": "string"
        },
        {
            "name": "lastLogin",
            "baseName": "last_login",
            "type": "string"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "avatarfull",
            "baseName": "avatarfull",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2006.attributeTypeMap;
    }
}

export class InlineResponse2007 {
    /**
    * account_id
    */
    'accountId': number;
    /**
    * name
    */
    'name': string;
    /**
    * country_code
    */
    'countryCode': string;
    /**
    * fantasy_role
    */
    'fantasyRole': number;
    /**
    * team_id
    */
    'teamId': number;
    /**
    * team_name
    */
    'teamName': string;
    /**
    * team_tag
    */
    'teamTag': string;
    /**
    * is_locked
    */
    'isLocked': boolean;
    /**
    * is_pro
    */
    'isPro': boolean;
    /**
    * locked_until
    */
    'lockedUntil': number;
    /**
    * steamid
    */
    'steamid': string;
    /**
    * avatar
    */
    'avatar': string;
    /**
    * avatarmedium
    */
    'avatarmedium': string;
    /**
    * avatarfull
    */
    'avatarfull': string;
    /**
    * profileurl
    */
    'profileurl': string;
    /**
    * cheese
    */
    'cheese': number;
    /**
    * fh_unavailable
    */
    'fhUnavailable': boolean;
    /**
    * loccountrycode
    */
    'loccountrycode': string;
    /**
    * last_played
    */
    'lastPlayed': number;
    /**
    * win
    */
    'win': number;
    /**
    * games
    */
    'games': number;
    /**
    * with_win
    */
    'withWin': number;
    /**
    * with_games
    */
    'withGames': number;
    /**
    * against_win
    */
    'againstWin': number;
    /**
    * against_games
    */
    'againstGames': number;
    /**
    * with_gpm_sum
    */
    'withGpmSum': number;
    /**
    * with_xpm_sum
    */
    'withXpmSum': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "account_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "fantasyRole",
            "baseName": "fantasy_role",
            "type": "number"
        },
        {
            "name": "teamId",
            "baseName": "team_id",
            "type": "number"
        },
        {
            "name": "teamName",
            "baseName": "team_name",
            "type": "string"
        },
        {
            "name": "teamTag",
            "baseName": "team_tag",
            "type": "string"
        },
        {
            "name": "isLocked",
            "baseName": "is_locked",
            "type": "boolean"
        },
        {
            "name": "isPro",
            "baseName": "is_pro",
            "type": "boolean"
        },
        {
            "name": "lockedUntil",
            "baseName": "locked_until",
            "type": "number"
        },
        {
            "name": "steamid",
            "baseName": "steamid",
            "type": "string"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "avatarmedium",
            "baseName": "avatarmedium",
            "type": "string"
        },
        {
            "name": "avatarfull",
            "baseName": "avatarfull",
            "type": "string"
        },
        {
            "name": "profileurl",
            "baseName": "profileurl",
            "type": "string"
        },
        {
            "name": "cheese",
            "baseName": "cheese",
            "type": "number"
        },
        {
            "name": "fhUnavailable",
            "baseName": "fh_unavailable",
            "type": "boolean"
        },
        {
            "name": "loccountrycode",
            "baseName": "loccountrycode",
            "type": "string"
        },
        {
            "name": "lastPlayed",
            "baseName": "last_played",
            "type": "number"
        },
        {
            "name": "win",
            "baseName": "win",
            "type": "number"
        },
        {
            "name": "games",
            "baseName": "games",
            "type": "number"
        },
        {
            "name": "withWin",
            "baseName": "with_win",
            "type": "number"
        },
        {
            "name": "withGames",
            "baseName": "with_games",
            "type": "number"
        },
        {
            "name": "againstWin",
            "baseName": "against_win",
            "type": "number"
        },
        {
            "name": "againstGames",
            "baseName": "against_games",
            "type": "number"
        },
        {
            "name": "withGpmSum",
            "baseName": "with_gpm_sum",
            "type": "number"
        },
        {
            "name": "withXpmSum",
            "baseName": "with_xpm_sum",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2007.attributeTypeMap;
    }
}

export class InlineResponse2008 {
    /**
    * field
    */
    'field': string;
    /**
    * number
    */
    'n': number;
    /**
    * sum
    */
    'sum': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "string"
        },
        {
            "name": "n",
            "baseName": "n",
            "type": "number"
        },
        {
            "name": "sum",
            "baseName": "sum",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2008.attributeTypeMap;
    }
}

export class InlineResponse2009 {
    /**
    * leaver_status
    */
    'leaverStatus': any;
    /**
    * game_mode
    */
    'gameMode': any;
    /**
    * lobby_type
    */
    'lobbyType': any;
    /**
    * lane_role
    */
    'laneRole': any;
    /**
    * region
    */
    'region': any;
    /**
    * patch
    */
    'patch': any;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "leaverStatus",
            "baseName": "leaver_status",
            "type": "any"
        },
        {
            "name": "gameMode",
            "baseName": "game_mode",
            "type": "any"
        },
        {
            "name": "lobbyType",
            "baseName": "lobby_type",
            "type": "any"
        },
        {
            "name": "laneRole",
            "baseName": "lane_role",
            "type": "any"
        },
        {
            "name": "region",
            "baseName": "region",
            "type": "any"
        },
        {
            "name": "patch",
            "baseName": "patch",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2009.attributeTypeMap;
    }
}

export class InlineResponse200BuybackLog {
    /**
    * time
    */
    'time': number;
    /**
    * slot
    */
    'slot': number;
    /**
    * player_slot
    */
    'playerSlot': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "time",
            "baseName": "time",
            "type": "number"
        },
        {
            "name": "slot",
            "baseName": "slot",
            "type": "number"
        },
        {
            "name": "playerSlot",
            "baseName": "player_slot",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse200BuybackLog.attributeTypeMap;
    }
}

export class InlineResponse200Chat {
    /**
    * time
    */
    'time': number;
    /**
    * player name
    */
    'unit': string;
    /**
    * words
    */
    'key': string;
    /**
    * slot
    */
    'slot': number;
    /**
    * player_slot
    */
    'playerSlot': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "time",
            "baseName": "time",
            "type": "number"
        },
        {
            "name": "unit",
            "baseName": "unit",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "slot",
            "baseName": "slot",
            "type": "number"
        },
        {
            "name": "playerSlot",
            "baseName": "player_slot",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse200Chat.attributeTypeMap;
    }
}

export class InlineResponse200KillsLog {
    /**
    * time
    */
    'time': number;
    /**
    * key
    */
    'key': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "time",
            "baseName": "time",
            "type": "number"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse200KillsLog.attributeTypeMap;
    }
}

/**
* player
*/
export class InlineResponse200Players {
    /**
    * match_id
    */
    'matchId': number;
    /**
    * player_slot
    */
    'playerSlot': number;
    /**
    * ability_upgrades_arr
    */
    'abilityUpgradesArr': Array<number>;
    /**
    * ability_uses
    */
    'abilityUses': any;
    /**
    * account_id
    */
    'accountId': number;
    /**
    * actions
    */
    'actions': any;
    /**
    * additional_units
    */
    'additionalUnits': any;
    /**
    * assists
    */
    'assists': number;
    /**
    * backpack_0
    */
    'backpack0': number;
    /**
    * backpack_1
    */
    'backpack1': number;
    /**
    * backpack_2
    */
    'backpack2': number;
    /**
    * buyback_log
    */
    'buybackLog': Array<InlineResponse200BuybackLog>;
    /**
    * camps_stacked
    */
    'campsStacked': number;
    /**
    * creeps_stacked
    */
    'creepsStacked': number;
    /**
    * damage
    */
    'damage': any;
    /**
    * damage_inflictor
    */
    'damageInflictor': any;
    /**
    * damage_inflictor_received
    */
    'damageInflictorReceived': any;
    /**
    * damage_taken
    */
    'damageTaken': any;
    /**
    * deaths
    */
    'deaths': number;
    /**
    * denies
    */
    'denies': number;
    /**
    * dn_t
    */
    'dnT': Array<number>;
    /**
    * gold
    */
    'gold': number;
    /**
    * gold_per_min
    */
    'goldPerMin': number;
    /**
    * gold_reasons
    */
    'goldReasons': any;
    /**
    * gold_spent
    */
    'goldSpent': number;
    /**
    * gold_t
    */
    'goldT': Array<number>;
    /**
    * hero_damage
    */
    'heroDamage': number;
    /**
    * hero_healing
    */
    'heroHealing': number;
    /**
    * hero_hits
    */
    'heroHits': any;
    /**
    * hero_id
    */
    'heroId': number;
    /**
    * item_0
    */
    'item0': number;
    /**
    * item_1
    */
    'item1': number;
    /**
    * item_2
    */
    'item2': number;
    /**
    * item_3
    */
    'item3': number;
    /**
    * item_4
    */
    'item4': number;
    /**
    * item_5
    */
    'item5': number;
    /**
    * item_uses
    */
    'itemUses': any;
    /**
    * kill_streaks
    */
    'killStreaks': any;
    /**
    * killed
    */
    'killed': any;
    /**
    * killed_by
    */
    'killedBy': any;
    /**
    * kills
    */
    'kills': number;
    /**
    * kills_log
    */
    'killsLog': Array<InlineResponse200KillsLog>;
    /**
    * lane_pos
    */
    'lanePos': any;
    /**
    * last_hits
    */
    'lastHits': number;
    /**
    * leaver_status
    */
    'leaverStatus': number;
    /**
    * level
    */
    'level': number;
    /**
    * lh_t
    */
    'lhT': Array<number>;
    /**
    * life_state
    */
    'lifeState': any;
    /**
    * max_hero_hit
    */
    'maxHeroHit': any;
    /**
    * multi_kills
    */
    'multiKills': any;
    /**
    * obs
    */
    'obs': any;
    /**
    * obs_left_log
    */
    'obsLeftLog': Array<any>;
    /**
    * obs_log
    */
    'obsLog': Array<any>;
    /**
    * obs_placed
    */
    'obsPlaced': number;
    /**
    * party_id
    */
    'partyId': number;
    /**
    * permanent_buffs
    */
    'permanentBuffs': Array<any>;
    /**
    * pings
    */
    'pings': number;
    /**
    * purchase
    */
    'purchase': any;
    /**
    * purchase_log
    */
    'purchaseLog': Array<InlineResponse200KillsLog>;
    /**
    * rune_pickups
    */
    'runePickups': number;
    /**
    * runes
    */
    'runes': { [key: string]: number; };
    /**
    * runes_log
    */
    'runesLog': Array<InlineResponse200RunesLog>;
    /**
    * sen
    */
    'sen': any;
    /**
    * sen_left_log
    */
    'senLeftLog': Array<any>;
    /**
    * sen_log
    */
    'senLog': Array<any>;
    /**
    * sen_placed
    */
    'senPlaced': number;
    /**
    * stuns
    */
    'stuns': number;
    /**
    * times
    */
    'times': Array<number>;
    /**
    * tower_damage
    */
    'towerDamage': number;
    /**
    * xp_per_min
    */
    'xpPerMin': number;
    /**
    * xp_reasons
    */
    'xpReasons': any;
    /**
    * xp_t
    */
    'xpT': Array<number>;
    /**
    * personaname
    */
    'personaname': string;
    /**
    * name
    */
    'name': string;
    /**
    * radiant_win
    */
    'radiantWin': boolean;
    /**
    * start_time
    */
    'startTime': number;
    /**
    * duration
    */
    'duration': number;
    /**
    * cluster
    */
    'cluster': number;
    /**
    * lobby_type
    */
    'lobbyType': number;
    /**
    * game_mode
    */
    'gameMode': number;
    /**
    * patch
    */
    'patch': number;
    /**
    * region
    */
    'region': number;
    /**
    * isRadiant
    */
    'isRadiant': boolean;
    /**
    * win
    */
    'win': number;
    /**
    * win
    */
    'lose': number;
    /**
    * total_gold
    */
    'totalGold': number;
    /**
    * total_xp
    */
    'totalXp': number;
    /**
    * kills_per_min
    */
    'killsPerMin': number;
    /**
    * kda
    */
    'kda': number;
    /**
    * abandons
    */
    'abandons': number;
    /**
    * neutral_kills
    */
    'neutralKills': number;
    /**
    * tower_kills
    */
    'towerKills': number;
    /**
    * courier_kills
    */
    'courierKills': number;
    /**
    * lane_kills
    */
    'laneKills': number;
    /**
    * hero_kills
    */
    'heroKills': number;
    /**
    * observer_kills
    */
    'observerKills': number;
    /**
    * sentry_kills
    */
    'sentryKills': number;
    /**
    * roshan_kills
    */
    'roshanKills': number;
    /**
    * necronomicon_kills
    */
    'necronomiconKills': number;
    /**
    * ancient_kills
    */
    'ancientKills': number;
    /**
    * buyback_count
    */
    'buybackCount': number;
    /**
    * observer_uses
    */
    'observerUses': number;
    /**
    * sentry_uses
    */
    'sentryUses': number;
    /**
    * lane_efficiency
    */
    'laneEfficiency': number;
    /**
    * lane_efficiency_pct
    */
    'laneEfficiencyPct': number;
    /**
    * lane
    */
    'lane': number;
    /**
    * lane_role
    */
    'laneRole': number;
    /**
    * is_roaming
    */
    'isRoaming': boolean;
    /**
    * purchase_time
    */
    'purchaseTime': any;
    /**
    * first_purchase_time
    */
    'firstPurchaseTime': any;
    /**
    * item_win
    */
    'itemWin': any;
    /**
    * item_usage
    */
    'itemUsage': any;
    /**
    * purchase_tpscroll
    */
    'purchaseTpscroll': any;
    /**
    * actions_per_min
    */
    'actionsPerMin': number;
    /**
    * life_state_dead
    */
    'lifeStateDead': number;
    /**
    * solo_competitive_rank
    */
    'soloCompetitiveRank': string;
    /**
    * cosmetics
    */
    'cosmetics': Array<number>;
    /**
    * benchmarks
    */
    'benchmarks': any;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "matchId",
            "baseName": "match_id",
            "type": "number"
        },
        {
            "name": "playerSlot",
            "baseName": "player_slot",
            "type": "number"
        },
        {
            "name": "abilityUpgradesArr",
            "baseName": "ability_upgrades_arr",
            "type": "Array<number>"
        },
        {
            "name": "abilityUses",
            "baseName": "ability_uses",
            "type": "any"
        },
        {
            "name": "accountId",
            "baseName": "account_id",
            "type": "number"
        },
        {
            "name": "actions",
            "baseName": "actions",
            "type": "any"
        },
        {
            "name": "additionalUnits",
            "baseName": "additional_units",
            "type": "any"
        },
        {
            "name": "assists",
            "baseName": "assists",
            "type": "number"
        },
        {
            "name": "backpack0",
            "baseName": "backpack_0",
            "type": "number"
        },
        {
            "name": "backpack1",
            "baseName": "backpack_1",
            "type": "number"
        },
        {
            "name": "backpack2",
            "baseName": "backpack_2",
            "type": "number"
        },
        {
            "name": "buybackLog",
            "baseName": "buyback_log",
            "type": "Array<InlineResponse200BuybackLog>"
        },
        {
            "name": "campsStacked",
            "baseName": "camps_stacked",
            "type": "number"
        },
        {
            "name": "creepsStacked",
            "baseName": "creeps_stacked",
            "type": "number"
        },
        {
            "name": "damage",
            "baseName": "damage",
            "type": "any"
        },
        {
            "name": "damageInflictor",
            "baseName": "damage_inflictor",
            "type": "any"
        },
        {
            "name": "damageInflictorReceived",
            "baseName": "damage_inflictor_received",
            "type": "any"
        },
        {
            "name": "damageTaken",
            "baseName": "damage_taken",
            "type": "any"
        },
        {
            "name": "deaths",
            "baseName": "deaths",
            "type": "number"
        },
        {
            "name": "denies",
            "baseName": "denies",
            "type": "number"
        },
        {
            "name": "dnT",
            "baseName": "dn_t",
            "type": "Array<number>"
        },
        {
            "name": "gold",
            "baseName": "gold",
            "type": "number"
        },
        {
            "name": "goldPerMin",
            "baseName": "gold_per_min",
            "type": "number"
        },
        {
            "name": "goldReasons",
            "baseName": "gold_reasons",
            "type": "any"
        },
        {
            "name": "goldSpent",
            "baseName": "gold_spent",
            "type": "number"
        },
        {
            "name": "goldT",
            "baseName": "gold_t",
            "type": "Array<number>"
        },
        {
            "name": "heroDamage",
            "baseName": "hero_damage",
            "type": "number"
        },
        {
            "name": "heroHealing",
            "baseName": "hero_healing",
            "type": "number"
        },
        {
            "name": "heroHits",
            "baseName": "hero_hits",
            "type": "any"
        },
        {
            "name": "heroId",
            "baseName": "hero_id",
            "type": "number"
        },
        {
            "name": "item0",
            "baseName": "item_0",
            "type": "number"
        },
        {
            "name": "item1",
            "baseName": "item_1",
            "type": "number"
        },
        {
            "name": "item2",
            "baseName": "item_2",
            "type": "number"
        },
        {
            "name": "item3",
            "baseName": "item_3",
            "type": "number"
        },
        {
            "name": "item4",
            "baseName": "item_4",
            "type": "number"
        },
        {
            "name": "item5",
            "baseName": "item_5",
            "type": "number"
        },
        {
            "name": "itemUses",
            "baseName": "item_uses",
            "type": "any"
        },
        {
            "name": "killStreaks",
            "baseName": "kill_streaks",
            "type": "any"
        },
        {
            "name": "killed",
            "baseName": "killed",
            "type": "any"
        },
        {
            "name": "killedBy",
            "baseName": "killed_by",
            "type": "any"
        },
        {
            "name": "kills",
            "baseName": "kills",
            "type": "number"
        },
        {
            "name": "killsLog",
            "baseName": "kills_log",
            "type": "Array<InlineResponse200KillsLog>"
        },
        {
            "name": "lanePos",
            "baseName": "lane_pos",
            "type": "any"
        },
        {
            "name": "lastHits",
            "baseName": "last_hits",
            "type": "number"
        },
        {
            "name": "leaverStatus",
            "baseName": "leaver_status",
            "type": "number"
        },
        {
            "name": "level",
            "baseName": "level",
            "type": "number"
        },
        {
            "name": "lhT",
            "baseName": "lh_t",
            "type": "Array<number>"
        },
        {
            "name": "lifeState",
            "baseName": "life_state",
            "type": "any"
        },
        {
            "name": "maxHeroHit",
            "baseName": "max_hero_hit",
            "type": "any"
        },
        {
            "name": "multiKills",
            "baseName": "multi_kills",
            "type": "any"
        },
        {
            "name": "obs",
            "baseName": "obs",
            "type": "any"
        },
        {
            "name": "obsLeftLog",
            "baseName": "obs_left_log",
            "type": "Array<any>"
        },
        {
            "name": "obsLog",
            "baseName": "obs_log",
            "type": "Array<any>"
        },
        {
            "name": "obsPlaced",
            "baseName": "obs_placed",
            "type": "number"
        },
        {
            "name": "partyId",
            "baseName": "party_id",
            "type": "number"
        },
        {
            "name": "permanentBuffs",
            "baseName": "permanent_buffs",
            "type": "Array<any>"
        },
        {
            "name": "pings",
            "baseName": "pings",
            "type": "number"
        },
        {
            "name": "purchase",
            "baseName": "purchase",
            "type": "any"
        },
        {
            "name": "purchaseLog",
            "baseName": "purchase_log",
            "type": "Array<InlineResponse200KillsLog>"
        },
        {
            "name": "runePickups",
            "baseName": "rune_pickups",
            "type": "number"
        },
        {
            "name": "runes",
            "baseName": "runes",
            "type": "{ [key: string]: number; }"
        },
        {
            "name": "runesLog",
            "baseName": "runes_log",
            "type": "Array<InlineResponse200RunesLog>"
        },
        {
            "name": "sen",
            "baseName": "sen",
            "type": "any"
        },
        {
            "name": "senLeftLog",
            "baseName": "sen_left_log",
            "type": "Array<any>"
        },
        {
            "name": "senLog",
            "baseName": "sen_log",
            "type": "Array<any>"
        },
        {
            "name": "senPlaced",
            "baseName": "sen_placed",
            "type": "number"
        },
        {
            "name": "stuns",
            "baseName": "stuns",
            "type": "number"
        },
        {
            "name": "times",
            "baseName": "times",
            "type": "Array<number>"
        },
        {
            "name": "towerDamage",
            "baseName": "tower_damage",
            "type": "number"
        },
        {
            "name": "xpPerMin",
            "baseName": "xp_per_min",
            "type": "number"
        },
        {
            "name": "xpReasons",
            "baseName": "xp_reasons",
            "type": "any"
        },
        {
            "name": "xpT",
            "baseName": "xp_t",
            "type": "Array<number>"
        },
        {
            "name": "personaname",
            "baseName": "personaname",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "radiantWin",
            "baseName": "radiant_win",
            "type": "boolean"
        },
        {
            "name": "startTime",
            "baseName": "start_time",
            "type": "number"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "cluster",
            "baseName": "cluster",
            "type": "number"
        },
        {
            "name": "lobbyType",
            "baseName": "lobby_type",
            "type": "number"
        },
        {
            "name": "gameMode",
            "baseName": "game_mode",
            "type": "number"
        },
        {
            "name": "patch",
            "baseName": "patch",
            "type": "number"
        },
        {
            "name": "region",
            "baseName": "region",
            "type": "number"
        },
        {
            "name": "isRadiant",
            "baseName": "isRadiant",
            "type": "boolean"
        },
        {
            "name": "win",
            "baseName": "win",
            "type": "number"
        },
        {
            "name": "lose",
            "baseName": "lose",
            "type": "number"
        },
        {
            "name": "totalGold",
            "baseName": "total_gold",
            "type": "number"
        },
        {
            "name": "totalXp",
            "baseName": "total_xp",
            "type": "number"
        },
        {
            "name": "killsPerMin",
            "baseName": "kills_per_min",
            "type": "number"
        },
        {
            "name": "kda",
            "baseName": "kda",
            "type": "number"
        },
        {
            "name": "abandons",
            "baseName": "abandons",
            "type": "number"
        },
        {
            "name": "neutralKills",
            "baseName": "neutral_kills",
            "type": "number"
        },
        {
            "name": "towerKills",
            "baseName": "tower_kills",
            "type": "number"
        },
        {
            "name": "courierKills",
            "baseName": "courier_kills",
            "type": "number"
        },
        {
            "name": "laneKills",
            "baseName": "lane_kills",
            "type": "number"
        },
        {
            "name": "heroKills",
            "baseName": "hero_kills",
            "type": "number"
        },
        {
            "name": "observerKills",
            "baseName": "observer_kills",
            "type": "number"
        },
        {
            "name": "sentryKills",
            "baseName": "sentry_kills",
            "type": "number"
        },
        {
            "name": "roshanKills",
            "baseName": "roshan_kills",
            "type": "number"
        },
        {
            "name": "necronomiconKills",
            "baseName": "necronomicon_kills",
            "type": "number"
        },
        {
            "name": "ancientKills",
            "baseName": "ancient_kills",
            "type": "number"
        },
        {
            "name": "buybackCount",
            "baseName": "buyback_count",
            "type": "number"
        },
        {
            "name": "observerUses",
            "baseName": "observer_uses",
            "type": "number"
        },
        {
            "name": "sentryUses",
            "baseName": "sentry_uses",
            "type": "number"
        },
        {
            "name": "laneEfficiency",
            "baseName": "lane_efficiency",
            "type": "number"
        },
        {
            "name": "laneEfficiencyPct",
            "baseName": "lane_efficiency_pct",
            "type": "number"
        },
        {
            "name": "lane",
            "baseName": "lane",
            "type": "number"
        },
        {
            "name": "laneRole",
            "baseName": "lane_role",
            "type": "number"
        },
        {
            "name": "isRoaming",
            "baseName": "is_roaming",
            "type": "boolean"
        },
        {
            "name": "purchaseTime",
            "baseName": "purchase_time",
            "type": "any"
        },
        {
            "name": "firstPurchaseTime",
            "baseName": "first_purchase_time",
            "type": "any"
        },
        {
            "name": "itemWin",
            "baseName": "item_win",
            "type": "any"
        },
        {
            "name": "itemUsage",
            "baseName": "item_usage",
            "type": "any"
        },
        {
            "name": "purchaseTpscroll",
            "baseName": "purchase_tpscroll",
            "type": "any"
        },
        {
            "name": "actionsPerMin",
            "baseName": "actions_per_min",
            "type": "number"
        },
        {
            "name": "lifeStateDead",
            "baseName": "life_state_dead",
            "type": "number"
        },
        {
            "name": "soloCompetitiveRank",
            "baseName": "solo_competitive_rank",
            "type": "string"
        },
        {
            "name": "cosmetics",
            "baseName": "cosmetics",
            "type": "Array<number>"
        },
        {
            "name": "benchmarks",
            "baseName": "benchmarks",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse200Players.attributeTypeMap;
    }
}

export class InlineResponse200RunesLog {
    /**
    * time
    */
    'time': number;
    /**
    * key
    */
    'key': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "time",
            "baseName": "time",
            "type": "number"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse200RunesLog.attributeTypeMap;
    }
}

/**
* heroes (requires ?project=heroes)
*/
export class PlayersaccountIdmatchesHeroes {
    'playerSlot': PlayersaccountIdmatchesHeroesPlayerSlot;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "playerSlot",
            "baseName": "player_slot",
            "type": "PlayersaccountIdmatchesHeroesPlayerSlot"
        }    ];

    static getAttributeTypeMap() {
        return PlayersaccountIdmatchesHeroes.attributeTypeMap;
    }
}

/**
* player_slot
*/
export class PlayersaccountIdmatchesHeroesPlayerSlot {
    /**
    * account_id
    */
    'accountId': number;
    /**
    * hero_id
    */
    'heroId': number;
    /**
    * player_slot
    */
    'playerSlot': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "account_id",
            "type": "number"
        },
        {
            "name": "heroId",
            "baseName": "hero_id",
            "type": "number"
        },
        {
            "name": "playerSlot",
            "baseName": "player_slot",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PlayersaccountIdmatchesHeroesPlayerSlot.attributeTypeMap;
    }
}


let enumsMap = {
}

let typeMap = {
    "InlineResponse200": InlineResponse200,
    "InlineResponse2001": InlineResponse2001,
    "InlineResponse20010": InlineResponse20010,
    "InlineResponse20011": InlineResponse20011,
    "InlineResponse20012": InlineResponse20012,
    "InlineResponse20013": InlineResponse20013,
    "InlineResponse20014": InlineResponse20014,
    "InlineResponse20015": InlineResponse20015,
    "InlineResponse20016": InlineResponse20016,
    "InlineResponse20016Cheese": InlineResponse20016Cheese,
    "InlineResponse20017": InlineResponse20017,
    "InlineResponse20017CountryMmr": InlineResponse20017CountryMmr,
    "InlineResponse20017CountryMmrFields": InlineResponse20017CountryMmrFields,
    "InlineResponse20017CountryMmrRows": InlineResponse20017CountryMmrRows,
    "InlineResponse20017Mmr": InlineResponse20017Mmr,
    "InlineResponse20017MmrFields": InlineResponse20017MmrFields,
    "InlineResponse20017MmrRows": InlineResponse20017MmrRows,
    "InlineResponse20017MmrSum": InlineResponse20017MmrSum,
    "InlineResponse20018": InlineResponse20018,
    "InlineResponse20019": InlineResponse20019,
    "InlineResponse20019Rankings": InlineResponse20019Rankings,
    "InlineResponse2001MmrEstimate": InlineResponse2001MmrEstimate,
    "InlineResponse2001Profile": InlineResponse2001Profile,
    "InlineResponse2002": InlineResponse2002,
    "InlineResponse20020": InlineResponse20020,
    "InlineResponse20020Result": InlineResponse20020Result,
    "InlineResponse20020ResultGoldPerMin": InlineResponse20020ResultGoldPerMin,
    "InlineResponse20021": InlineResponse20021,
    "InlineResponse20022": InlineResponse20022,
    "InlineResponse20023": InlineResponse20023,
    "InlineResponse20024": InlineResponse20024,
    "InlineResponse20025": InlineResponse20025,
    "InlineResponse20026": InlineResponse20026,
    "InlineResponse20027": InlineResponse20027,
    "InlineResponse20028": InlineResponse20028,
    "InlineResponse20029": InlineResponse20029,
    "InlineResponse2003": InlineResponse2003,
    "InlineResponse20030": InlineResponse20030,
    "InlineResponse2004": InlineResponse2004,
    "InlineResponse2005": InlineResponse2005,
    "InlineResponse2006": InlineResponse2006,
    "InlineResponse2007": InlineResponse2007,
    "InlineResponse2008": InlineResponse2008,
    "InlineResponse2009": InlineResponse2009,
    "InlineResponse200BuybackLog": InlineResponse200BuybackLog,
    "InlineResponse200Chat": InlineResponse200Chat,
    "InlineResponse200KillsLog": InlineResponse200KillsLog,
    "InlineResponse200Players": InlineResponse200Players,
    "InlineResponse200RunesLog": InlineResponse200RunesLog,
    "PlayersaccountIdmatchesHeroes": PlayersaccountIdmatchesHeroes,
    "PlayersaccountIdmatchesHeroesPlayerSlot": PlayersaccountIdmatchesHeroesPlayerSlot,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum BenchmarksApiApiKeys {
}

export class BenchmarksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BenchmarksApiApiKeys, value: string) {
        this.authentications[BenchmarksApiApiKeys[key]].apiKey = value;
    }
    /**
     * Benchmarks of average stat values for a hero
     * @summary GET /benchmarks
     * @param heroId Hero ID
     */
    public benchmarksGet (heroId: string) : Promise<{ response: http.ClientResponse; body: InlineResponse20020;  }> {
        const localVarPath = this.basePath + '/benchmarks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'heroId' is not null or undefined
        if (heroId === null || heroId === undefined) {
            throw new Error('Required parameter heroId was null or undefined when calling benchmarksGet.');
        }

        if (heroId !== undefined) {
            localVarQueryParameters['hero_id'] = ObjectSerializer.serialize(heroId, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20020;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20020");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DistributionsApiApiKeys {
}

export class DistributionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DistributionsApiApiKeys, value: string) {
        this.authentications[DistributionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Distributions of MMR data by bracket and country
     * @summary GET /distributions
     */
    public distributionsGet () : Promise<{ response: http.ClientResponse; body: InlineResponse20017;  }> {
        const localVarPath = this.basePath + '/distributions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20017;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20017");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ExplorerApiApiKeys {
}

export class ExplorerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ExplorerApiApiKeys, value: string) {
        this.authentications[ExplorerApiApiKeys[key]].apiKey = value;
    }
    /**
     * Submit arbitrary SQL queries to the database
     * @summary GET /explorer
     * @param sql The PostgreSQL query as percent-encoded string.
     */
    public explorerGet (sql?: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/explorer';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (sql !== undefined) {
            localVarQueryParameters['sql'] = ObjectSerializer.serialize(sql, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HealthApiApiKeys {
}

export class HealthApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HealthApiApiKeys, value: string) {
        this.authentications[HealthApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get service health data
     * @summary GET /health
     */
    public healthGet () : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/health';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HeroStatsApiApiKeys {
}

export class HeroStatsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HeroStatsApiApiKeys, value: string) {
        this.authentications[HeroStatsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get stats about hero performance in recent matches
     * @summary GET /heroStats
     */
    public heroStatsGet () : Promise<{ response: http.ClientResponse; body: Array<InlineResponse20022>;  }> {
        const localVarPath = this.basePath + '/heroStats';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse20022>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse20022>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HeroesApiApiKeys {
}

export class HeroesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HeroesApiApiKeys, value: string) {
        this.authentications[HeroesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get hero data
     * @summary GET /heroes
     */
    public heroesGet () : Promise<{ response: http.ClientResponse; body: Array<InlineResponse20021>;  }> {
        const localVarPath = this.basePath + '/heroes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse20021>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse20021>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get hero performance over a range of match durations
     * @summary GET /heroes/{hero_id}/durations
     */
    public heroesHeroIdDurationsGet () : Promise<{ response: http.ClientResponse; body: Array<InlineResponse20023>;  }> {
        const localVarPath = this.basePath + '/heroes/{hero_id}/durations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse20023>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse20023>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get recent matches with a hero
     * @summary GET /heroes/{hero_id}/matches
     */
    public heroesHeroIdMatchesGet () : Promise<{ response: http.ClientResponse; body: Array<InlineResponse20014>;  }> {
        const localVarPath = this.basePath + '/heroes/{hero_id}/matches';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse20014>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse20014>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get results against other heroes for a hero
     * @summary GET /heroes/{hero_id}/matchups
     */
    public heroesHeroIdMatchupsGet () : Promise<{ response: http.ClientResponse; body: Array<InlineResponse20021>;  }> {
        const localVarPath = this.basePath + '/heroes/{hero_id}/matchups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse20021>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse20021>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get players who have played this hero
     * @summary GET /heroes/{hero_id}/players
     */
    public heroesHeroIdPlayersGet () : Promise<{ response: http.ClientResponse; body: Array<Array<any>>;  }> {
        const localVarPath = this.basePath + '/heroes/{hero_id}/players';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Array<any>>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Array<any>>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LeaguesApiApiKeys {
}

export class LeaguesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LeaguesApiApiKeys, value: string) {
        this.authentications[LeaguesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get league data
     * @summary GET /leagues
     */
    public leaguesGet () : Promise<{ response: http.ClientResponse; body: Array<InlineResponse20024>;  }> {
        const localVarPath = this.basePath + '/leagues';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse20024>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse20024>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LiveApiApiKeys {
}

export class LiveApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LiveApiApiKeys, value: string) {
        this.authentications[LiveApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get top currently ongoing live games
     * @summary GET /live
     */
    public liveGet () : Promise<{ response: http.ClientResponse; body: Array<any>;  }> {
        const localVarPath = this.basePath + '/live';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<any>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<any>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MatchesApiApiKeys {
}

export class MatchesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MatchesApiApiKeys, value: string) {
        this.authentications[MatchesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Match data
     * @summary GET /matches/{match_id}
     * @param matchId 
     */
    public matchesMatchIdGet (matchId: number) : Promise<{ response: http.ClientResponse; body: InlineResponse200;  }> {
        const localVarPath = this.basePath + '/matches/{match_id}'
            .replace('{' + 'match_id' + '}', encodeURIComponent(String(matchId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'matchId' is not null or undefined
        if (matchId === null || matchId === undefined) {
            throw new Error('Required parameter matchId was null or undefined when calling matchesMatchIdGet.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse200;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse200");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MetadataApiApiKeys {
}

export class MetadataApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MetadataApiApiKeys, value: string) {
        this.authentications[MetadataApiApiKeys[key]].apiKey = value;
    }
    /**
     * Site metadata
     * @summary GET /metadata
     */
    public metadataGet () : Promise<{ response: http.ClientResponse; body: InlineResponse20016;  }> {
        const localVarPath = this.basePath + '/metadata';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20016;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20016");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PlayersApiApiKeys {
}

export class PlayersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PlayersApiApiKeys, value: string) {
        this.authentications[PlayersApiApiKeys[key]].apiKey = value;
    }
    /**
     * Counts in categories
     * @summary GET /players/{account_id}/counts
     * @param accountId Steam32 account ID
     * @param limit Number of matches to limit to
     * @param offset Number of matches to offset start by
     * @param win Whether the player won
     * @param patch Patch ID
     * @param gameMode Game Mode ID
     * @param lobbyType Lobby type ID
     * @param region Region ID
     * @param date Days previous
     * @param laneRole Lane Role ID
     * @param heroId Hero ID
     * @param isRadiant Whether the player was radiant
     * @param includedAccountId Account IDs in the match (array)
     * @param excludedAccountId Account IDs not in the match (array)
     * @param withHeroId Hero IDs on the player&#39;s team (array)
     * @param againstHeroId Hero IDs against the player&#39;s team (array)
     * @param significant Whether the match was significant for aggregation purposes
     * @param sort The field to return matches sorted by in descending order
     */
    public playersAccountIdCountsGet (accountId: number, limit?: number, offset?: number, win?: number, patch?: number, gameMode?: number, lobbyType?: number, region?: number, date?: number, laneRole?: number, heroId?: number, isRadiant?: number, includedAccountId?: number, excludedAccountId?: number, withHeroId?: number, againstHeroId?: number, significant?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse2009;  }> {
        const localVarPath = this.basePath + '/players/{account_id}/counts'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling playersAccountIdCountsGet.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (win !== undefined) {
            localVarQueryParameters['win'] = ObjectSerializer.serialize(win, "number");
        }

        if (patch !== undefined) {
            localVarQueryParameters['patch'] = ObjectSerializer.serialize(patch, "number");
        }

        if (gameMode !== undefined) {
            localVarQueryParameters['game_mode'] = ObjectSerializer.serialize(gameMode, "number");
        }

        if (lobbyType !== undefined) {
            localVarQueryParameters['lobby_type'] = ObjectSerializer.serialize(lobbyType, "number");
        }

        if (region !== undefined) {
            localVarQueryParameters['region'] = ObjectSerializer.serialize(region, "number");
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "number");
        }

        if (laneRole !== undefined) {
            localVarQueryParameters['lane_role'] = ObjectSerializer.serialize(laneRole, "number");
        }

        if (heroId !== undefined) {
            localVarQueryParameters['hero_id'] = ObjectSerializer.serialize(heroId, "number");
        }

        if (isRadiant !== undefined) {
            localVarQueryParameters['is_radiant'] = ObjectSerializer.serialize(isRadiant, "number");
        }

        if (includedAccountId !== undefined) {
            localVarQueryParameters['included_account_id'] = ObjectSerializer.serialize(includedAccountId, "number");
        }

        if (excludedAccountId !== undefined) {
            localVarQueryParameters['excluded_account_id'] = ObjectSerializer.serialize(excludedAccountId, "number");
        }

        if (withHeroId !== undefined) {
            localVarQueryParameters['with_hero_id'] = ObjectSerializer.serialize(withHeroId, "number");
        }

        if (againstHeroId !== undefined) {
            localVarQueryParameters['against_hero_id'] = ObjectSerializer.serialize(againstHeroId, "number");
        }

        if (significant !== undefined) {
            localVarQueryParameters['significant'] = ObjectSerializer.serialize(significant, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2009;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2009");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Player data
     * @summary GET /players/{account_id}
     * @param accountId Steam32 account ID
     */
    public playersAccountIdGet (accountId: number) : Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }> {
        const localVarPath = this.basePath + '/players/{account_id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling playersAccountIdGet.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2001");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Heroes played
     * @summary GET /players/{account_id}/heroes
     * @param accountId Steam32 account ID
     * @param limit Number of matches to limit to
     * @param offset Number of matches to offset start by
     * @param win Whether the player won
     * @param patch Patch ID
     * @param gameMode Game Mode ID
     * @param lobbyType Lobby type ID
     * @param region Region ID
     * @param date Days previous
     * @param laneRole Lane Role ID
     * @param heroId Hero ID
     * @param isRadiant Whether the player was radiant
     * @param includedAccountId Account IDs in the match (array)
     * @param excludedAccountId Account IDs not in the match (array)
     * @param withHeroId Hero IDs on the player&#39;s team (array)
     * @param againstHeroId Hero IDs against the player&#39;s team (array)
     * @param significant Whether the match was significant for aggregation purposes
     * @param sort The field to return matches sorted by in descending order
     */
    public playersAccountIdHeroesGet (accountId: number, limit?: number, offset?: number, win?: number, patch?: number, gameMode?: number, lobbyType?: number, region?: number, date?: number, laneRole?: number, heroId?: number, isRadiant?: number, includedAccountId?: number, excludedAccountId?: number, withHeroId?: number, againstHeroId?: number, significant?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse2005>;  }> {
        const localVarPath = this.basePath + '/players/{account_id}/heroes'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling playersAccountIdHeroesGet.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (win !== undefined) {
            localVarQueryParameters['win'] = ObjectSerializer.serialize(win, "number");
        }

        if (patch !== undefined) {
            localVarQueryParameters['patch'] = ObjectSerializer.serialize(patch, "number");
        }

        if (gameMode !== undefined) {
            localVarQueryParameters['game_mode'] = ObjectSerializer.serialize(gameMode, "number");
        }

        if (lobbyType !== undefined) {
            localVarQueryParameters['lobby_type'] = ObjectSerializer.serialize(lobbyType, "number");
        }

        if (region !== undefined) {
            localVarQueryParameters['region'] = ObjectSerializer.serialize(region, "number");
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "number");
        }

        if (laneRole !== undefined) {
            localVarQueryParameters['lane_role'] = ObjectSerializer.serialize(laneRole, "number");
        }

        if (heroId !== undefined) {
            localVarQueryParameters['hero_id'] = ObjectSerializer.serialize(heroId, "number");
        }

        if (isRadiant !== undefined) {
            localVarQueryParameters['is_radiant'] = ObjectSerializer.serialize(isRadiant, "number");
        }

        if (includedAccountId !== undefined) {
            localVarQueryParameters['included_account_id'] = ObjectSerializer.serialize(includedAccountId, "number");
        }

        if (excludedAccountId !== undefined) {
            localVarQueryParameters['excluded_account_id'] = ObjectSerializer.serialize(excludedAccountId, "number");
        }

        if (withHeroId !== undefined) {
            localVarQueryParameters['with_hero_id'] = ObjectSerializer.serialize(withHeroId, "number");
        }

        if (againstHeroId !== undefined) {
            localVarQueryParameters['against_hero_id'] = ObjectSerializer.serialize(againstHeroId, "number");
        }

        if (significant !== undefined) {
            localVarQueryParameters['significant'] = ObjectSerializer.serialize(significant, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse2005>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse2005>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Distribution of matches in a single stat
     * @summary GET /players/{account_id}/histograms
     * @param accountId Steam32 account ID
     * @param field Field to aggregate on
     * @param limit Number of matches to limit to
     * @param offset Number of matches to offset start by
     * @param win Whether the player won
     * @param patch Patch ID
     * @param gameMode Game Mode ID
     * @param lobbyType Lobby type ID
     * @param region Region ID
     * @param date Days previous
     * @param laneRole Lane Role ID
     * @param heroId Hero ID
     * @param isRadiant Whether the player was radiant
     * @param includedAccountId Account IDs in the match (array)
     * @param excludedAccountId Account IDs not in the match (array)
     * @param withHeroId Hero IDs on the player&#39;s team (array)
     * @param againstHeroId Hero IDs against the player&#39;s team (array)
     * @param significant Whether the match was significant for aggregation purposes
     * @param sort The field to return matches sorted by in descending order
     */
    public playersAccountIdHistogramsFieldGet (accountId: number, field: string, limit?: number, offset?: number, win?: number, patch?: number, gameMode?: number, lobbyType?: number, region?: number, date?: number, laneRole?: number, heroId?: number, isRadiant?: number, includedAccountId?: number, excludedAccountId?: number, withHeroId?: number, againstHeroId?: number, significant?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: Array<any>;  }> {
        const localVarPath = this.basePath + '/players/{account_id}/histograms/{field}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'field' + '}', encodeURIComponent(String(field)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling playersAccountIdHistogramsFieldGet.');
        }

        // verify required parameter 'field' is not null or undefined
        if (field === null || field === undefined) {
            throw new Error('Required parameter field was null or undefined when calling playersAccountIdHistogramsFieldGet.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (win !== undefined) {
            localVarQueryParameters['win'] = ObjectSerializer.serialize(win, "number");
        }

        if (patch !== undefined) {
            localVarQueryParameters['patch'] = ObjectSerializer.serialize(patch, "number");
        }

        if (gameMode !== undefined) {
            localVarQueryParameters['game_mode'] = ObjectSerializer.serialize(gameMode, "number");
        }

        if (lobbyType !== undefined) {
            localVarQueryParameters['lobby_type'] = ObjectSerializer.serialize(lobbyType, "number");
        }

        if (region !== undefined) {
            localVarQueryParameters['region'] = ObjectSerializer.serialize(region, "number");
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "number");
        }

        if (laneRole !== undefined) {
            localVarQueryParameters['lane_role'] = ObjectSerializer.serialize(laneRole, "number");
        }

        if (heroId !== undefined) {
            localVarQueryParameters['hero_id'] = ObjectSerializer.serialize(heroId, "number");
        }

        if (isRadiant !== undefined) {
            localVarQueryParameters['is_radiant'] = ObjectSerializer.serialize(isRadiant, "number");
        }

        if (includedAccountId !== undefined) {
            localVarQueryParameters['included_account_id'] = ObjectSerializer.serialize(includedAccountId, "number");
        }

        if (excludedAccountId !== undefined) {
            localVarQueryParameters['excluded_account_id'] = ObjectSerializer.serialize(excludedAccountId, "number");
        }

        if (withHeroId !== undefined) {
            localVarQueryParameters['with_hero_id'] = ObjectSerializer.serialize(withHeroId, "number");
        }

        if (againstHeroId !== undefined) {
            localVarQueryParameters['against_hero_id'] = ObjectSerializer.serialize(againstHeroId, "number");
        }

        if (significant !== undefined) {
            localVarQueryParameters['significant'] = ObjectSerializer.serialize(significant, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<any>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<any>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Matches played
     * @summary GET /players/{account_id}/matches
     * @param accountId Steam32 account ID
     * @param limit Number of matches to limit to
     * @param offset Number of matches to offset start by
     * @param win Whether the player won
     * @param patch Patch ID
     * @param gameMode Game Mode ID
     * @param lobbyType Lobby type ID
     * @param region Region ID
     * @param date Days previous
     * @param laneRole Lane Role ID
     * @param heroId Hero ID
     * @param isRadiant Whether the player was radiant
     * @param includedAccountId Account IDs in the match (array)
     * @param excludedAccountId Account IDs not in the match (array)
     * @param withHeroId Hero IDs on the player&#39;s team (array)
     * @param againstHeroId Hero IDs against the player&#39;s team (array)
     * @param significant Whether the match was significant for aggregation purposes
     * @param sort The field to return matches sorted by in descending order
     * @param project Fields to project (array)
     */
    public playersAccountIdMatchesGet (accountId: number, limit?: number, offset?: number, win?: number, patch?: number, gameMode?: number, lobbyType?: number, region?: number, date?: number, laneRole?: number, heroId?: number, isRadiant?: number, includedAccountId?: number, excludedAccountId?: number, withHeroId?: number, againstHeroId?: number, significant?: number, sort?: string, project?: string) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse2004>;  }> {
        const localVarPath = this.basePath + '/players/{account_id}/matches'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling playersAccountIdMatchesGet.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (win !== undefined) {
            localVarQueryParameters['win'] = ObjectSerializer.serialize(win, "number");
        }

        if (patch !== undefined) {
            localVarQueryParameters['patch'] = ObjectSerializer.serialize(patch, "number");
        }

        if (gameMode !== undefined) {
            localVarQueryParameters['game_mode'] = ObjectSerializer.serialize(gameMode, "number");
        }

        if (lobbyType !== undefined) {
            localVarQueryParameters['lobby_type'] = ObjectSerializer.serialize(lobbyType, "number");
        }

        if (region !== undefined) {
            localVarQueryParameters['region'] = ObjectSerializer.serialize(region, "number");
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "number");
        }

        if (laneRole !== undefined) {
            localVarQueryParameters['lane_role'] = ObjectSerializer.serialize(laneRole, "number");
        }

        if (heroId !== undefined) {
            localVarQueryParameters['hero_id'] = ObjectSerializer.serialize(heroId, "number");
        }

        if (isRadiant !== undefined) {
            localVarQueryParameters['is_radiant'] = ObjectSerializer.serialize(isRadiant, "number");
        }

        if (includedAccountId !== undefined) {
            localVarQueryParameters['included_account_id'] = ObjectSerializer.serialize(includedAccountId, "number");
        }

        if (excludedAccountId !== undefined) {
            localVarQueryParameters['excluded_account_id'] = ObjectSerializer.serialize(excludedAccountId, "number");
        }

        if (withHeroId !== undefined) {
            localVarQueryParameters['with_hero_id'] = ObjectSerializer.serialize(withHeroId, "number");
        }

        if (againstHeroId !== undefined) {
            localVarQueryParameters['against_hero_id'] = ObjectSerializer.serialize(againstHeroId, "number");
        }

        if (significant !== undefined) {
            localVarQueryParameters['significant'] = ObjectSerializer.serialize(significant, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (project !== undefined) {
            localVarQueryParameters['project'] = ObjectSerializer.serialize(project, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse2004>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse2004>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Players played with
     * @summary GET /players/{account_id}/peers
     * @param accountId Steam32 account ID
     * @param limit Number of matches to limit to
     * @param offset Number of matches to offset start by
     * @param win Whether the player won
     * @param patch Patch ID
     * @param gameMode Game Mode ID
     * @param lobbyType Lobby type ID
     * @param region Region ID
     * @param date Days previous
     * @param laneRole Lane Role ID
     * @param heroId Hero ID
     * @param isRadiant Whether the player was radiant
     * @param includedAccountId Account IDs in the match (array)
     * @param excludedAccountId Account IDs not in the match (array)
     * @param withHeroId Hero IDs on the player&#39;s team (array)
     * @param againstHeroId Hero IDs against the player&#39;s team (array)
     * @param significant Whether the match was significant for aggregation purposes
     * @param sort The field to return matches sorted by in descending order
     */
    public playersAccountIdPeersGet (accountId: number, limit?: number, offset?: number, win?: number, patch?: number, gameMode?: number, lobbyType?: number, region?: number, date?: number, laneRole?: number, heroId?: number, isRadiant?: number, includedAccountId?: number, excludedAccountId?: number, withHeroId?: number, againstHeroId?: number, significant?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse2006>;  }> {
        const localVarPath = this.basePath + '/players/{account_id}/peers'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling playersAccountIdPeersGet.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (win !== undefined) {
            localVarQueryParameters['win'] = ObjectSerializer.serialize(win, "number");
        }

        if (patch !== undefined) {
            localVarQueryParameters['patch'] = ObjectSerializer.serialize(patch, "number");
        }

        if (gameMode !== undefined) {
            localVarQueryParameters['game_mode'] = ObjectSerializer.serialize(gameMode, "number");
        }

        if (lobbyType !== undefined) {
            localVarQueryParameters['lobby_type'] = ObjectSerializer.serialize(lobbyType, "number");
        }

        if (region !== undefined) {
            localVarQueryParameters['region'] = ObjectSerializer.serialize(region, "number");
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "number");
        }

        if (laneRole !== undefined) {
            localVarQueryParameters['lane_role'] = ObjectSerializer.serialize(laneRole, "number");
        }

        if (heroId !== undefined) {
            localVarQueryParameters['hero_id'] = ObjectSerializer.serialize(heroId, "number");
        }

        if (isRadiant !== undefined) {
            localVarQueryParameters['is_radiant'] = ObjectSerializer.serialize(isRadiant, "number");
        }

        if (includedAccountId !== undefined) {
            localVarQueryParameters['included_account_id'] = ObjectSerializer.serialize(includedAccountId, "number");
        }

        if (excludedAccountId !== undefined) {
            localVarQueryParameters['excluded_account_id'] = ObjectSerializer.serialize(excludedAccountId, "number");
        }

        if (withHeroId !== undefined) {
            localVarQueryParameters['with_hero_id'] = ObjectSerializer.serialize(withHeroId, "number");
        }

        if (againstHeroId !== undefined) {
            localVarQueryParameters['against_hero_id'] = ObjectSerializer.serialize(againstHeroId, "number");
        }

        if (significant !== undefined) {
            localVarQueryParameters['significant'] = ObjectSerializer.serialize(significant, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse2006>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse2006>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Pro players played with
     * @summary GET /players/{account_id}/pros
     * @param accountId Steam32 account ID
     * @param limit Number of matches to limit to
     * @param offset Number of matches to offset start by
     * @param win Whether the player won
     * @param patch Patch ID
     * @param gameMode Game Mode ID
     * @param lobbyType Lobby type ID
     * @param region Region ID
     * @param date Days previous
     * @param laneRole Lane Role ID
     * @param heroId Hero ID
     * @param isRadiant Whether the player was radiant
     * @param includedAccountId Account IDs in the match (array)
     * @param excludedAccountId Account IDs not in the match (array)
     * @param withHeroId Hero IDs on the player&#39;s team (array)
     * @param againstHeroId Hero IDs against the player&#39;s team (array)
     * @param significant Whether the match was significant for aggregation purposes
     * @param sort The field to return matches sorted by in descending order
     */
    public playersAccountIdProsGet (accountId: number, limit?: number, offset?: number, win?: number, patch?: number, gameMode?: number, lobbyType?: number, region?: number, date?: number, laneRole?: number, heroId?: number, isRadiant?: number, includedAccountId?: number, excludedAccountId?: number, withHeroId?: number, againstHeroId?: number, significant?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse2007>;  }> {
        const localVarPath = this.basePath + '/players/{account_id}/pros'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling playersAccountIdProsGet.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (win !== undefined) {
            localVarQueryParameters['win'] = ObjectSerializer.serialize(win, "number");
        }

        if (patch !== undefined) {
            localVarQueryParameters['patch'] = ObjectSerializer.serialize(patch, "number");
        }

        if (gameMode !== undefined) {
            localVarQueryParameters['game_mode'] = ObjectSerializer.serialize(gameMode, "number");
        }

        if (lobbyType !== undefined) {
            localVarQueryParameters['lobby_type'] = ObjectSerializer.serialize(lobbyType, "number");
        }

        if (region !== undefined) {
            localVarQueryParameters['region'] = ObjectSerializer.serialize(region, "number");
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "number");
        }

        if (laneRole !== undefined) {
            localVarQueryParameters['lane_role'] = ObjectSerializer.serialize(laneRole, "number");
        }

        if (heroId !== undefined) {
            localVarQueryParameters['hero_id'] = ObjectSerializer.serialize(heroId, "number");
        }

        if (isRadiant !== undefined) {
            localVarQueryParameters['is_radiant'] = ObjectSerializer.serialize(isRadiant, "number");
        }

        if (includedAccountId !== undefined) {
            localVarQueryParameters['included_account_id'] = ObjectSerializer.serialize(includedAccountId, "number");
        }

        if (excludedAccountId !== undefined) {
            localVarQueryParameters['excluded_account_id'] = ObjectSerializer.serialize(excludedAccountId, "number");
        }

        if (withHeroId !== undefined) {
            localVarQueryParameters['with_hero_id'] = ObjectSerializer.serialize(withHeroId, "number");
        }

        if (againstHeroId !== undefined) {
            localVarQueryParameters['against_hero_id'] = ObjectSerializer.serialize(againstHeroId, "number");
        }

        if (significant !== undefined) {
            localVarQueryParameters['significant'] = ObjectSerializer.serialize(significant, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse2007>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse2007>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Player hero rankings
     * @summary GET /players/{account_id}/rankings
     * @param accountId Steam32 account ID
     */
    public playersAccountIdRankingsGet (accountId: number) : Promise<{ response: http.ClientResponse; body: Array<any>;  }> {
        const localVarPath = this.basePath + '/players/{account_id}/rankings'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling playersAccountIdRankingsGet.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<any>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<any>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Player rating history
     * @summary GET /players/{account_id}/ratings
     * @param accountId Steam32 account ID
     */
    public playersAccountIdRatingsGet (accountId: number) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse20012>;  }> {
        const localVarPath = this.basePath + '/players/{account_id}/ratings'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling playersAccountIdRatingsGet.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse20012>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse20012>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Recent matches played
     * @summary GET /players/{account_id}/recentMatches
     */
    public playersAccountIdRecentMatchesGet () : Promise<{ response: http.ClientResponse; body: Array<InlineResponse2003>;  }> {
        const localVarPath = this.basePath + '/players/{account_id}/recentMatches';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse2003>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse2003>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Refresh player match history
     * @summary POST /players/{account_id}/refresh
     * @param accountId Steam32 account ID
     */
    public playersAccountIdRefreshPost (accountId: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/players/{account_id}/refresh'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling playersAccountIdRefreshPost.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Totals in stats
     * @summary GET /players/{account_id}/totals
     * @param accountId Steam32 account ID
     * @param limit Number of matches to limit to
     * @param offset Number of matches to offset start by
     * @param win Whether the player won
     * @param patch Patch ID
     * @param gameMode Game Mode ID
     * @param lobbyType Lobby type ID
     * @param region Region ID
     * @param date Days previous
     * @param laneRole Lane Role ID
     * @param heroId Hero ID
     * @param isRadiant Whether the player was radiant
     * @param includedAccountId Account IDs in the match (array)
     * @param excludedAccountId Account IDs not in the match (array)
     * @param withHeroId Hero IDs on the player&#39;s team (array)
     * @param againstHeroId Hero IDs against the player&#39;s team (array)
     * @param significant Whether the match was significant for aggregation purposes
     * @param sort The field to return matches sorted by in descending order
     */
    public playersAccountIdTotalsGet (accountId: number, limit?: number, offset?: number, win?: number, patch?: number, gameMode?: number, lobbyType?: number, region?: number, date?: number, laneRole?: number, heroId?: number, isRadiant?: number, includedAccountId?: number, excludedAccountId?: number, withHeroId?: number, againstHeroId?: number, significant?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse2008>;  }> {
        const localVarPath = this.basePath + '/players/{account_id}/totals'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling playersAccountIdTotalsGet.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (win !== undefined) {
            localVarQueryParameters['win'] = ObjectSerializer.serialize(win, "number");
        }

        if (patch !== undefined) {
            localVarQueryParameters['patch'] = ObjectSerializer.serialize(patch, "number");
        }

        if (gameMode !== undefined) {
            localVarQueryParameters['game_mode'] = ObjectSerializer.serialize(gameMode, "number");
        }

        if (lobbyType !== undefined) {
            localVarQueryParameters['lobby_type'] = ObjectSerializer.serialize(lobbyType, "number");
        }

        if (region !== undefined) {
            localVarQueryParameters['region'] = ObjectSerializer.serialize(region, "number");
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "number");
        }

        if (laneRole !== undefined) {
            localVarQueryParameters['lane_role'] = ObjectSerializer.serialize(laneRole, "number");
        }

        if (heroId !== undefined) {
            localVarQueryParameters['hero_id'] = ObjectSerializer.serialize(heroId, "number");
        }

        if (isRadiant !== undefined) {
            localVarQueryParameters['is_radiant'] = ObjectSerializer.serialize(isRadiant, "number");
        }

        if (includedAccountId !== undefined) {
            localVarQueryParameters['included_account_id'] = ObjectSerializer.serialize(includedAccountId, "number");
        }

        if (excludedAccountId !== undefined) {
            localVarQueryParameters['excluded_account_id'] = ObjectSerializer.serialize(excludedAccountId, "number");
        }

        if (withHeroId !== undefined) {
            localVarQueryParameters['with_hero_id'] = ObjectSerializer.serialize(withHeroId, "number");
        }

        if (againstHeroId !== undefined) {
            localVarQueryParameters['against_hero_id'] = ObjectSerializer.serialize(againstHeroId, "number");
        }

        if (significant !== undefined) {
            localVarQueryParameters['significant'] = ObjectSerializer.serialize(significant, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse2008>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse2008>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Wards placed in matches played
     * @summary GET /players/{account_id}/wardmap
     * @param accountId Steam32 account ID
     * @param limit Number of matches to limit to
     * @param offset Number of matches to offset start by
     * @param win Whether the player won
     * @param patch Patch ID
     * @param gameMode Game Mode ID
     * @param lobbyType Lobby type ID
     * @param region Region ID
     * @param date Days previous
     * @param laneRole Lane Role ID
     * @param heroId Hero ID
     * @param isRadiant Whether the player was radiant
     * @param includedAccountId Account IDs in the match (array)
     * @param excludedAccountId Account IDs not in the match (array)
     * @param withHeroId Hero IDs on the player&#39;s team (array)
     * @param againstHeroId Hero IDs against the player&#39;s team (array)
     * @param significant Whether the match was significant for aggregation purposes
     * @param sort The field to return matches sorted by in descending order
     */
    public playersAccountIdWardmapGet (accountId: number, limit?: number, offset?: number, win?: number, patch?: number, gameMode?: number, lobbyType?: number, region?: number, date?: number, laneRole?: number, heroId?: number, isRadiant?: number, includedAccountId?: number, excludedAccountId?: number, withHeroId?: number, againstHeroId?: number, significant?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse20010;  }> {
        const localVarPath = this.basePath + '/players/{account_id}/wardmap'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling playersAccountIdWardmapGet.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (win !== undefined) {
            localVarQueryParameters['win'] = ObjectSerializer.serialize(win, "number");
        }

        if (patch !== undefined) {
            localVarQueryParameters['patch'] = ObjectSerializer.serialize(patch, "number");
        }

        if (gameMode !== undefined) {
            localVarQueryParameters['game_mode'] = ObjectSerializer.serialize(gameMode, "number");
        }

        if (lobbyType !== undefined) {
            localVarQueryParameters['lobby_type'] = ObjectSerializer.serialize(lobbyType, "number");
        }

        if (region !== undefined) {
            localVarQueryParameters['region'] = ObjectSerializer.serialize(region, "number");
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "number");
        }

        if (laneRole !== undefined) {
            localVarQueryParameters['lane_role'] = ObjectSerializer.serialize(laneRole, "number");
        }

        if (heroId !== undefined) {
            localVarQueryParameters['hero_id'] = ObjectSerializer.serialize(heroId, "number");
        }

        if (isRadiant !== undefined) {
            localVarQueryParameters['is_radiant'] = ObjectSerializer.serialize(isRadiant, "number");
        }

        if (includedAccountId !== undefined) {
            localVarQueryParameters['included_account_id'] = ObjectSerializer.serialize(includedAccountId, "number");
        }

        if (excludedAccountId !== undefined) {
            localVarQueryParameters['excluded_account_id'] = ObjectSerializer.serialize(excludedAccountId, "number");
        }

        if (withHeroId !== undefined) {
            localVarQueryParameters['with_hero_id'] = ObjectSerializer.serialize(withHeroId, "number");
        }

        if (againstHeroId !== undefined) {
            localVarQueryParameters['against_hero_id'] = ObjectSerializer.serialize(againstHeroId, "number");
        }

        if (significant !== undefined) {
            localVarQueryParameters['significant'] = ObjectSerializer.serialize(significant, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20010;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20010");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Win/Loss count
     * @summary GET /players/{account_id}/wl
     * @param accountId Steam32 account ID
     * @param limit Number of matches to limit to
     * @param offset Number of matches to offset start by
     * @param win Whether the player won
     * @param patch Patch ID
     * @param gameMode Game Mode ID
     * @param lobbyType Lobby type ID
     * @param region Region ID
     * @param date Days previous
     * @param laneRole Lane Role ID
     * @param heroId Hero ID
     * @param isRadiant Whether the player was radiant
     * @param includedAccountId Account IDs in the match (array)
     * @param excludedAccountId Account IDs not in the match (array)
     * @param withHeroId Hero IDs on the player&#39;s team (array)
     * @param againstHeroId Hero IDs against the player&#39;s team (array)
     * @param significant Whether the match was significant for aggregation purposes
     * @param sort The field to return matches sorted by in descending order
     */
    public playersAccountIdWlGet (accountId: number, limit?: number, offset?: number, win?: number, patch?: number, gameMode?: number, lobbyType?: number, region?: number, date?: number, laneRole?: number, heroId?: number, isRadiant?: number, includedAccountId?: number, excludedAccountId?: number, withHeroId?: number, againstHeroId?: number, significant?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }> {
        const localVarPath = this.basePath + '/players/{account_id}/wl'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling playersAccountIdWlGet.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (win !== undefined) {
            localVarQueryParameters['win'] = ObjectSerializer.serialize(win, "number");
        }

        if (patch !== undefined) {
            localVarQueryParameters['patch'] = ObjectSerializer.serialize(patch, "number");
        }

        if (gameMode !== undefined) {
            localVarQueryParameters['game_mode'] = ObjectSerializer.serialize(gameMode, "number");
        }

        if (lobbyType !== undefined) {
            localVarQueryParameters['lobby_type'] = ObjectSerializer.serialize(lobbyType, "number");
        }

        if (region !== undefined) {
            localVarQueryParameters['region'] = ObjectSerializer.serialize(region, "number");
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "number");
        }

        if (laneRole !== undefined) {
            localVarQueryParameters['lane_role'] = ObjectSerializer.serialize(laneRole, "number");
        }

        if (heroId !== undefined) {
            localVarQueryParameters['hero_id'] = ObjectSerializer.serialize(heroId, "number");
        }

        if (isRadiant !== undefined) {
            localVarQueryParameters['is_radiant'] = ObjectSerializer.serialize(isRadiant, "number");
        }

        if (includedAccountId !== undefined) {
            localVarQueryParameters['included_account_id'] = ObjectSerializer.serialize(includedAccountId, "number");
        }

        if (excludedAccountId !== undefined) {
            localVarQueryParameters['excluded_account_id'] = ObjectSerializer.serialize(excludedAccountId, "number");
        }

        if (withHeroId !== undefined) {
            localVarQueryParameters['with_hero_id'] = ObjectSerializer.serialize(withHeroId, "number");
        }

        if (againstHeroId !== undefined) {
            localVarQueryParameters['against_hero_id'] = ObjectSerializer.serialize(againstHeroId, "number");
        }

        if (significant !== undefined) {
            localVarQueryParameters['significant'] = ObjectSerializer.serialize(significant, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2002");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Words said/read in matches played
     * @summary GET /players/{account_id}/wordcloud
     * @param accountId Steam32 account ID
     * @param limit Number of matches to limit to
     * @param offset Number of matches to offset start by
     * @param win Whether the player won
     * @param patch Patch ID
     * @param gameMode Game Mode ID
     * @param lobbyType Lobby type ID
     * @param region Region ID
     * @param date Days previous
     * @param laneRole Lane Role ID
     * @param heroId Hero ID
     * @param isRadiant Whether the player was radiant
     * @param includedAccountId Account IDs in the match (array)
     * @param excludedAccountId Account IDs not in the match (array)
     * @param withHeroId Hero IDs on the player&#39;s team (array)
     * @param againstHeroId Hero IDs against the player&#39;s team (array)
     * @param significant Whether the match was significant for aggregation purposes
     * @param sort The field to return matches sorted by in descending order
     */
    public playersAccountIdWordcloudGet (accountId: number, limit?: number, offset?: number, win?: number, patch?: number, gameMode?: number, lobbyType?: number, region?: number, date?: number, laneRole?: number, heroId?: number, isRadiant?: number, includedAccountId?: number, excludedAccountId?: number, withHeroId?: number, againstHeroId?: number, significant?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse20011;  }> {
        const localVarPath = this.basePath + '/players/{account_id}/wordcloud'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling playersAccountIdWordcloudGet.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (win !== undefined) {
            localVarQueryParameters['win'] = ObjectSerializer.serialize(win, "number");
        }

        if (patch !== undefined) {
            localVarQueryParameters['patch'] = ObjectSerializer.serialize(patch, "number");
        }

        if (gameMode !== undefined) {
            localVarQueryParameters['game_mode'] = ObjectSerializer.serialize(gameMode, "number");
        }

        if (lobbyType !== undefined) {
            localVarQueryParameters['lobby_type'] = ObjectSerializer.serialize(lobbyType, "number");
        }

        if (region !== undefined) {
            localVarQueryParameters['region'] = ObjectSerializer.serialize(region, "number");
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "number");
        }

        if (laneRole !== undefined) {
            localVarQueryParameters['lane_role'] = ObjectSerializer.serialize(laneRole, "number");
        }

        if (heroId !== undefined) {
            localVarQueryParameters['hero_id'] = ObjectSerializer.serialize(heroId, "number");
        }

        if (isRadiant !== undefined) {
            localVarQueryParameters['is_radiant'] = ObjectSerializer.serialize(isRadiant, "number");
        }

        if (includedAccountId !== undefined) {
            localVarQueryParameters['included_account_id'] = ObjectSerializer.serialize(includedAccountId, "number");
        }

        if (excludedAccountId !== undefined) {
            localVarQueryParameters['excluded_account_id'] = ObjectSerializer.serialize(excludedAccountId, "number");
        }

        if (withHeroId !== undefined) {
            localVarQueryParameters['with_hero_id'] = ObjectSerializer.serialize(withHeroId, "number");
        }

        if (againstHeroId !== undefined) {
            localVarQueryParameters['against_hero_id'] = ObjectSerializer.serialize(againstHeroId, "number");
        }

        if (significant !== undefined) {
            localVarQueryParameters['significant'] = ObjectSerializer.serialize(significant, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20011;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20011");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProMatchesApiApiKeys {
}

export class ProMatchesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProMatchesApiApiKeys, value: string) {
        this.authentications[ProMatchesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get list of pro matches
     * @summary GET /proMatches
     * @param lessThanMatchId Get matches with a match ID lower than this value
     */
    public proMatchesGet (lessThanMatchId?: number) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse20014>;  }> {
        const localVarPath = this.basePath + '/proMatches';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (lessThanMatchId !== undefined) {
            localVarQueryParameters['less_than_match_id'] = ObjectSerializer.serialize(lessThanMatchId, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse20014>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse20014>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProPlayersApiApiKeys {
}

export class ProPlayersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProPlayersApiApiKeys, value: string) {
        this.authentications[ProPlayersApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get list of pro players
     * @summary GET /proPlayers
     */
    public proPlayersGet () : Promise<{ response: http.ClientResponse; body: Array<InlineResponse20013>;  }> {
        const localVarPath = this.basePath + '/proPlayers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse20013>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse20013>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PublicMatchesApiApiKeys {
}

export class PublicMatchesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PublicMatchesApiApiKeys, value: string) {
        this.authentications[PublicMatchesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get list of randomly sampled public matches
     * @summary GET /publicMatches
     * @param mmrAscending Order by MMR ascending
     * @param mmrDescending Order by MMR descending
     * @param lessThanMatchId Get matches with a match ID lower than this value
     */
    public publicMatchesGet (mmrAscending?: number, mmrDescending?: number, lessThanMatchId?: number) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse20015>;  }> {
        const localVarPath = this.basePath + '/publicMatches';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (mmrAscending !== undefined) {
            localVarQueryParameters['mmr_ascending'] = ObjectSerializer.serialize(mmrAscending, "number");
        }

        if (mmrDescending !== undefined) {
            localVarQueryParameters['mmr_descending'] = ObjectSerializer.serialize(mmrDescending, "number");
        }

        if (lessThanMatchId !== undefined) {
            localVarQueryParameters['less_than_match_id'] = ObjectSerializer.serialize(lessThanMatchId, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse20015>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse20015>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RankingsApiApiKeys {
}

export class RankingsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RankingsApiApiKeys, value: string) {
        this.authentications[RankingsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Top players by hero
     * @summary GET /rankings
     * @param heroId Hero ID
     */
    public rankingsGet (heroId: string) : Promise<{ response: http.ClientResponse; body: InlineResponse20019;  }> {
        const localVarPath = this.basePath + '/rankings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'heroId' is not null or undefined
        if (heroId === null || heroId === undefined) {
            throw new Error('Required parameter heroId was null or undefined when calling rankingsGet.');
        }

        if (heroId !== undefined) {
            localVarQueryParameters['hero_id'] = ObjectSerializer.serialize(heroId, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20019;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20019");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RecordsApiApiKeys {
}

export class RecordsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RecordsApiApiKeys, value: string) {
        this.authentications[RecordsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get top performances in a stat
     * @summary GET /records/{field}
     * @param field Field name to query
     */
    public recordsFieldGet (field: string) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse20029>;  }> {
        const localVarPath = this.basePath + '/records/{field}'
            .replace('{' + 'field' + '}', encodeURIComponent(String(field)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'field' is not null or undefined
        if (field === null || field === undefined) {
            throw new Error('Required parameter field was null or undefined when calling recordsFieldGet.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse20029>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse20029>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReplaysApiApiKeys {
}

export class ReplaysApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReplaysApiApiKeys, value: string) {
        this.authentications[ReplaysApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get data to construct a replay URL with
     * @summary GET /replays
     * @param matchId Match IDs (array)
     */
    public replaysGet (matchId: number) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse20028>;  }> {
        const localVarPath = this.basePath + '/replays';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'matchId' is not null or undefined
        if (matchId === null || matchId === undefined) {
            throw new Error('Required parameter matchId was null or undefined when calling replaysGet.');
        }

        if (matchId !== undefined) {
            localVarQueryParameters['match_id'] = ObjectSerializer.serialize(matchId, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse20028>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse20028>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RequestApiApiKeys {
}

export class RequestApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RequestApiApiKeys, value: string) {
        this.authentications[RequestApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get parse request state
     * @summary GET /request/{jobId}
     * @param jobId The job ID to query.
     */
    public requestJobIdGet (jobId: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/request/{jobId}'
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'jobId' is not null or undefined
        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling requestJobIdGet.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Submit a new parse request
     * @summary POST /request/{match_id}
     * @param matchId 
     */
    public requestMatchIdPost (matchId: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/request/{match_id}'
            .replace('{' + 'match_id' + '}', encodeURIComponent(String(matchId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'matchId' is not null or undefined
        if (matchId === null || matchId === undefined) {
            throw new Error('Required parameter matchId was null or undefined when calling requestMatchIdPost.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SchemaApiApiKeys {
}

export class SchemaApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SchemaApiApiKeys, value: string) {
        this.authentications[SchemaApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get database schema
     * @summary GET /schema
     */
    public schemaGet () : Promise<{ response: http.ClientResponse; body: Array<InlineResponse20030>;  }> {
        const localVarPath = this.basePath + '/schema';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse20030>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse20030>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SearchApiApiKeys {
}

export class SearchApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SearchApiApiKeys, value: string) {
        this.authentications[SearchApiApiKeys[key]].apiKey = value;
    }
    /**
     * Search players by personaname. Default similarity is 0.51
     * @summary GET /search
     * @param q Search string
     * @param similarity Minimum similarity threshold, between 0 and 1
     */
    public searchGet (q: string, similarity?: number) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse20018>;  }> {
        const localVarPath = this.basePath + '/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'q' is not null or undefined
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling searchGet.');
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (similarity !== undefined) {
            localVarQueryParameters['similarity'] = ObjectSerializer.serialize(similarity, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse20018>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse20018>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StatusApiApiKeys {
}

export class StatusApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StatusApiApiKeys, value: string) {
        this.authentications[StatusApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get current service statistics
     * @summary GET /status
     */
    public statusGet () : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/status';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TeamsApiApiKeys {
}

export class TeamsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TeamsApiApiKeys, value: string) {
        this.authentications[TeamsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get team data
     * @summary GET /teams
     */
    public teamsGet () : Promise<{ response: http.ClientResponse; body: Array<InlineResponse20025>;  }> {
        const localVarPath = this.basePath + '/teams';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse20025>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse20025>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get data for a team
     * @summary GET /teams/{team_id}
     */
    public teamsTeamIdGet () : Promise<{ response: http.ClientResponse; body: InlineResponse20025;  }> {
        const localVarPath = this.basePath + '/teams/{team_id}';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20025;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20025");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get heroes for a team
     * @summary GET /teams/{team_id}/heroes
     */
    public teamsTeamIdHeroesGet () : Promise<{ response: http.ClientResponse; body: InlineResponse20027;  }> {
        const localVarPath = this.basePath + '/teams/{team_id}/heroes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20027;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20027");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get matches for a team
     * @summary GET /teams/{team_id}/matches
     */
    public teamsTeamIdMatchesGet () : Promise<{ response: http.ClientResponse; body: InlineResponse20014;  }> {
        const localVarPath = this.basePath + '/teams/{team_id}/matches';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20014;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20014");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get players who have played for a team
     * @summary GET /teams/{team_id}/players
     */
    public teamsTeamIdPlayersGet () : Promise<{ response: http.ClientResponse; body: InlineResponse20026;  }> {
        const localVarPath = this.basePath + '/teams/{team_id}/players';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20026;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20026");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
